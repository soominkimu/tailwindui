"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/valibot";
exports.ids = ["vendor-chunks/valibot"];
exports.modules = {

/***/ "(rsc)/./node_modules/valibot/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/valibot/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BIC_REGEX: () => (/* binding */ BIC_REGEX),\n/* harmony export */   BrandSymbol: () => (/* binding */ BrandSymbol),\n/* harmony export */   CUID2_REGEX: () => (/* binding */ CUID2_REGEX),\n/* harmony export */   DECIMAL_REGEX: () => (/* binding */ DECIMAL_REGEX),\n/* harmony export */   EMAIL_REGEX: () => (/* binding */ EMAIL_REGEX),\n/* harmony export */   EMOJI_REGEX: () => (/* binding */ EMOJI_REGEX),\n/* harmony export */   HEXADECIMAL_REGEX: () => (/* binding */ HEXADECIMAL_REGEX),\n/* harmony export */   HEX_COLOR_REGEX: () => (/* binding */ HEX_COLOR_REGEX),\n/* harmony export */   IMEI_REGEX: () => (/* binding */ IMEI_REGEX),\n/* harmony export */   IPV4_REGEX: () => (/* binding */ IPV4_REGEX),\n/* harmony export */   IPV6_REGEX: () => (/* binding */ IPV6_REGEX),\n/* harmony export */   ISO_DATE_REGEX: () => (/* binding */ ISO_DATE_REGEX),\n/* harmony export */   ISO_DATE_TIME_REGEX: () => (/* binding */ ISO_DATE_TIME_REGEX),\n/* harmony export */   ISO_TIMESTAMP_REGEX: () => (/* binding */ ISO_TIMESTAMP_REGEX),\n/* harmony export */   ISO_TIME_REGEX: () => (/* binding */ ISO_TIME_REGEX),\n/* harmony export */   ISO_TIME_SECOND_REGEX: () => (/* binding */ ISO_TIME_SECOND_REGEX),\n/* harmony export */   ISO_WEEK_REGEX: () => (/* binding */ ISO_WEEK_REGEX),\n/* harmony export */   MAC48_REGEX: () => (/* binding */ MAC48_REGEX),\n/* harmony export */   MAC64_REGEX: () => (/* binding */ MAC64_REGEX),\n/* harmony export */   OCTAL_REGEX: () => (/* binding */ OCTAL_REGEX),\n/* harmony export */   ULID_REGEX: () => (/* binding */ ULID_REGEX),\n/* harmony export */   UUID_REGEX: () => (/* binding */ UUID_REGEX),\n/* harmony export */   ValiError: () => (/* binding */ ValiError),\n/* harmony export */   actionIssue: () => (/* binding */ actionIssue),\n/* harmony export */   actionOutput: () => (/* binding */ actionOutput),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   anyAsync: () => (/* binding */ anyAsync),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   arrayAsync: () => (/* binding */ arrayAsync),\n/* harmony export */   bic: () => (/* binding */ bic),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   bigintAsync: () => (/* binding */ bigintAsync),\n/* harmony export */   blob: () => (/* binding */ blob),\n/* harmony export */   blobAsync: () => (/* binding */ blobAsync),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   booleanAsync: () => (/* binding */ booleanAsync),\n/* harmony export */   brand: () => (/* binding */ brand),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   coerceAsync: () => (/* binding */ coerceAsync),\n/* harmony export */   creditCard: () => (/* binding */ creditCard),\n/* harmony export */   cuid2: () => (/* binding */ cuid2),\n/* harmony export */   custom: () => (/* binding */ custom),\n/* harmony export */   customAsync: () => (/* binding */ customAsync),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   dateAsync: () => (/* binding */ dateAsync),\n/* harmony export */   decimal: () => (/* binding */ decimal),\n/* harmony export */   defaultArgs: () => (/* binding */ defaultArgs),\n/* harmony export */   discriminatedUnion: () => (/* binding */ discriminatedUnion),\n/* harmony export */   discriminatedUnionAsync: () => (/* binding */ discriminatedUnionAsync),\n/* harmony export */   email: () => (/* binding */ email),\n/* harmony export */   emoji: () => (/* binding */ emoji),\n/* harmony export */   endsWith: () => (/* binding */ endsWith),\n/* harmony export */   enumAsync: () => (/* binding */ enumAsync),\n/* harmony export */   enumType: () => (/* binding */ enumType),\n/* harmony export */   enumTypeAsync: () => (/* binding */ enumTypeAsync),\n/* harmony export */   enum_: () => (/* binding */ enum_),\n/* harmony export */   equal: () => (/* binding */ equal),\n/* harmony export */   excludes: () => (/* binding */ excludes),\n/* harmony export */   fallback: () => (/* binding */ fallback),\n/* harmony export */   fallbackAsync: () => (/* binding */ fallbackAsync),\n/* harmony export */   finite: () => (/* binding */ finite),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   forward: () => (/* binding */ forward),\n/* harmony export */   getDefault: () => (/* binding */ getDefault),\n/* harmony export */   getDefaultAsync: () => (/* binding */ getDefaultAsync),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getDefaultsAsync: () => (/* binding */ getDefaultsAsync),\n/* harmony export */   getFallback: () => (/* binding */ getFallback),\n/* harmony export */   getFallbackAsync: () => (/* binding */ getFallbackAsync),\n/* harmony export */   getFallbacks: () => (/* binding */ getFallbacks),\n/* harmony export */   getFallbacksAsync: () => (/* binding */ getFallbacksAsync),\n/* harmony export */   hexColor: () => (/* binding */ hexColor),\n/* harmony export */   hexadecimal: () => (/* binding */ hexadecimal),\n/* harmony export */   imei: () => (/* binding */ imei),\n/* harmony export */   includes: () => (/* binding */ includes),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   instanceAsync: () => (/* binding */ instanceAsync),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   intersect: () => (/* binding */ intersect),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   ip: () => (/* binding */ ip),\n/* harmony export */   ipv4: () => (/* binding */ ipv4),\n/* harmony export */   ipv6: () => (/* binding */ ipv6),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   isLuhnAlgo: () => (/* binding */ isLuhnAlgo),\n/* harmony export */   isoDate: () => (/* binding */ isoDate),\n/* harmony export */   isoDateTime: () => (/* binding */ isoDateTime),\n/* harmony export */   isoTime: () => (/* binding */ isoTime),\n/* harmony export */   isoTimeSecond: () => (/* binding */ isoTimeSecond),\n/* harmony export */   isoTimestamp: () => (/* binding */ isoTimestamp),\n/* harmony export */   isoWeek: () => (/* binding */ isoWeek),\n/* harmony export */   keyof: () => (/* binding */ keyof),\n/* harmony export */   length: () => (/* binding */ length),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   literalAsync: () => (/* binding */ literalAsync),\n/* harmony export */   mac: () => (/* binding */ mac),\n/* harmony export */   mac48: () => (/* binding */ mac48),\n/* harmony export */   mac64: () => (/* binding */ mac64),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mapAsync: () => (/* binding */ mapAsync),\n/* harmony export */   maxBytes: () => (/* binding */ maxBytes),\n/* harmony export */   maxLength: () => (/* binding */ maxLength),\n/* harmony export */   maxRange: () => (/* binding */ maxRange),\n/* harmony export */   maxSize: () => (/* binding */ maxSize),\n/* harmony export */   maxValue: () => (/* binding */ maxValue),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   mergeAsync: () => (/* binding */ mergeAsync),\n/* harmony export */   mimeType: () => (/* binding */ mimeType),\n/* harmony export */   minBytes: () => (/* binding */ minBytes),\n/* harmony export */   minLength: () => (/* binding */ minLength),\n/* harmony export */   minRange: () => (/* binding */ minRange),\n/* harmony export */   minSize: () => (/* binding */ minSize),\n/* harmony export */   minValue: () => (/* binding */ minValue),\n/* harmony export */   multipleOf: () => (/* binding */ multipleOf),\n/* harmony export */   nan: () => (/* binding */ nan),\n/* harmony export */   nanAsync: () => (/* binding */ nanAsync),\n/* harmony export */   nativeEnum: () => (/* binding */ nativeEnum),\n/* harmony export */   nativeEnumAsync: () => (/* binding */ nativeEnumAsync),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   neverAsync: () => (/* binding */ neverAsync),\n/* harmony export */   nonNullable: () => (/* binding */ nonNullable),\n/* harmony export */   nonNullableAsync: () => (/* binding */ nonNullableAsync),\n/* harmony export */   nonNullish: () => (/* binding */ nonNullish),\n/* harmony export */   nonNullishAsync: () => (/* binding */ nonNullishAsync),\n/* harmony export */   nonOptional: () => (/* binding */ nonOptional),\n/* harmony export */   nonOptionalAsync: () => (/* binding */ nonOptionalAsync),\n/* harmony export */   notBytes: () => (/* binding */ notBytes),\n/* harmony export */   notLength: () => (/* binding */ notLength),\n/* harmony export */   notSize: () => (/* binding */ notSize),\n/* harmony export */   notValue: () => (/* binding */ notValue),\n/* harmony export */   nullAsync: () => (/* binding */ nullAsync),\n/* harmony export */   nullType: () => (/* binding */ nullType),\n/* harmony export */   nullTypeAsync: () => (/* binding */ nullTypeAsync),\n/* harmony export */   null_: () => (/* binding */ null_),\n/* harmony export */   nullable: () => (/* binding */ nullable),\n/* harmony export */   nullableAsync: () => (/* binding */ nullableAsync),\n/* harmony export */   nullish: () => (/* binding */ nullish),\n/* harmony export */   nullishAsync: () => (/* binding */ nullishAsync),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   numberAsync: () => (/* binding */ numberAsync),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   objectAsync: () => (/* binding */ objectAsync),\n/* harmony export */   octal: () => (/* binding */ octal),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   omitAsync: () => (/* binding */ omitAsync),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   optionalAsync: () => (/* binding */ optionalAsync),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseAsync: () => (/* binding */ parseAsync),\n/* harmony export */   parseResult: () => (/* binding */ parseResult),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   partialAsync: () => (/* binding */ partialAsync),\n/* harmony export */   passthrough: () => (/* binding */ passthrough),\n/* harmony export */   passthroughAsync: () => (/* binding */ passthroughAsync),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   pickAsync: () => (/* binding */ pickAsync),\n/* harmony export */   picklist: () => (/* binding */ picklist),\n/* harmony export */   picklistAsync: () => (/* binding */ picklistAsync),\n/* harmony export */   pipeResult: () => (/* binding */ pipeResult),\n/* harmony export */   pipeResultAsync: () => (/* binding */ pipeResultAsync),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   recordAsync: () => (/* binding */ recordAsync),\n/* harmony export */   recursive: () => (/* binding */ recursive),\n/* harmony export */   recursiveAsync: () => (/* binding */ recursiveAsync),\n/* harmony export */   regex: () => (/* binding */ regex),\n/* harmony export */   required: () => (/* binding */ required),\n/* harmony export */   requiredAsync: () => (/* binding */ requiredAsync),\n/* harmony export */   restAndDefaultArgs: () => (/* binding */ restAndDefaultArgs),\n/* harmony export */   safeInteger: () => (/* binding */ safeInteger),\n/* harmony export */   safeParse: () => (/* binding */ safeParse),\n/* harmony export */   safeParseAsync: () => (/* binding */ safeParseAsync),\n/* harmony export */   schemaIssue: () => (/* binding */ schemaIssue),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setAsync: () => (/* binding */ setAsync),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   special: () => (/* binding */ special),\n/* harmony export */   specialAsync: () => (/* binding */ specialAsync),\n/* harmony export */   startsWith: () => (/* binding */ startsWith),\n/* harmony export */   strict: () => (/* binding */ strict),\n/* harmony export */   strictAsync: () => (/* binding */ strictAsync),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   stringAsync: () => (/* binding */ stringAsync),\n/* harmony export */   strip: () => (/* binding */ strip),\n/* harmony export */   stripAsync: () => (/* binding */ stripAsync),\n/* harmony export */   symbol: () => (/* binding */ symbol),\n/* harmony export */   symbolAsync: () => (/* binding */ symbolAsync),\n/* harmony export */   toCustom: () => (/* binding */ toCustom),\n/* harmony export */   toCustomAsync: () => (/* binding */ toCustomAsync),\n/* harmony export */   toLowerCase: () => (/* binding */ toLowerCase),\n/* harmony export */   toMaxValue: () => (/* binding */ toMaxValue),\n/* harmony export */   toMinValue: () => (/* binding */ toMinValue),\n/* harmony export */   toTrimmed: () => (/* binding */ toTrimmed),\n/* harmony export */   toTrimmedEnd: () => (/* binding */ toTrimmedEnd),\n/* harmony export */   toTrimmedStart: () => (/* binding */ toTrimmedStart),\n/* harmony export */   toUpperCase: () => (/* binding */ toUpperCase),\n/* harmony export */   transform: () => (/* binding */ transform),\n/* harmony export */   transformAsync: () => (/* binding */ transformAsync),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   tupleAsync: () => (/* binding */ tupleAsync),\n/* harmony export */   ulid: () => (/* binding */ ulid),\n/* harmony export */   undefinedAsync: () => (/* binding */ undefinedAsync),\n/* harmony export */   undefinedType: () => (/* binding */ undefinedType),\n/* harmony export */   undefinedTypeAsync: () => (/* binding */ undefinedTypeAsync),\n/* harmony export */   undefined_: () => (/* binding */ undefined_),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unionAsync: () => (/* binding */ unionAsync),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   unknownAsync: () => (/* binding */ unknownAsync),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   url: () => (/* binding */ url),\n/* harmony export */   useDefault: () => (/* binding */ useDefault),\n/* harmony export */   uuid: () => (/* binding */ uuid),\n/* harmony export */   value: () => (/* binding */ value),\n/* harmony export */   variant: () => (/* binding */ variant),\n/* harmony export */   variantAsync: () => (/* binding */ variantAsync),\n/* harmony export */   voidAsync: () => (/* binding */ voidAsync),\n/* harmony export */   voidType: () => (/* binding */ voidType),\n/* harmony export */   voidTypeAsync: () => (/* binding */ voidTypeAsync),\n/* harmony export */   void_: () => (/* binding */ void_),\n/* harmony export */   withDefault: () => (/* binding */ withDefault)\n/* harmony export */ });\n// src/error/flatten/flatten.ts\nfunction flatten(arg1) {\n  return (Array.isArray(arg1) ? arg1 : arg1.issues).reduce(\n    (flatErrors, issue) => {\n      if (issue.path) {\n        if (issue.path.every(\n          ({ key }) => typeof key === \"string\" || typeof key === \"number\"\n        )) {\n          const path = issue.path.map(({ key }) => key).join(\".\");\n          if (flatErrors.nested[path]) {\n            flatErrors.nested[path].push(issue.message);\n          } else {\n            flatErrors.nested[path] = [issue.message];\n          }\n        }\n      } else {\n        if (flatErrors.root) {\n          flatErrors.root.push(issue.message);\n        } else {\n          flatErrors.root = [issue.message];\n        }\n      }\n      return flatErrors;\n    },\n    { nested: {} }\n  );\n}\n\n// src/error/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  issues;\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/methods/brand/brand.ts\nvar BrandSymbol = Symbol(\"brand\");\nfunction brand(schema, name) {\n  return schema;\n}\n\n// src/methods/coerce/coerce.ts\nfunction coerce(schema, action) {\n  return {\n    ...schema,\n    _parse(input, info) {\n      return schema._parse(action(input), info);\n    }\n  };\n}\n\n// src/methods/coerce/coerceAsync.ts\nfunction coerceAsync(schema, action) {\n  return {\n    ...schema,\n    async _parse(input, info) {\n      return schema._parse(await action(input), info);\n    }\n  };\n}\n\n// src/utils/errorMessage/errorMessage.ts\nfunction errorMessage(message) {\n  return typeof message === \"function\" ? message() : message;\n}\n\n// src/utils/actionIssue/actionIssue.ts\nfunction actionIssue(validation, message, input, requirement, path) {\n  return {\n    issues: [\n      {\n        validation,\n        message: errorMessage(message),\n        input,\n        requirement,\n        path\n      }\n    ]\n  };\n}\n\n// src/utils/actionOutput/actionOutput.ts\nfunction actionOutput(output) {\n  return { output };\n}\n\n// src/utils/defaultArgs/defaultArgs.ts\nfunction defaultArgs(arg1, arg2) {\n  return Array.isArray(arg1) ? [void 0, arg1] : [arg1, arg2];\n}\n\n// src/utils/parseResult/parseResult.ts\nfunction parseResult(typed, output, issues) {\n  return { typed, output, issues };\n}\n\n// src/utils/restAndDefaultArgs/restAndDefaultArgs.ts\nfunction restAndDefaultArgs(arg1, arg2, arg3) {\n  if (!arg1 || typeof arg1 === \"object\" && !Array.isArray(arg1)) {\n    const [error2, pipe2] = defaultArgs(arg2, arg3);\n    return [arg1, error2, pipe2];\n  }\n  const [error, pipe] = defaultArgs(\n    arg1,\n    arg2\n  );\n  return [void 0, error, pipe];\n}\n\n// src/utils/isLuhnAlgo/isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/pipeResult/utils/pipeIssue/pipeIssue.ts\nfunction pipeIssue(info, issue) {\n  return {\n    reason: info?.reason,\n    validation: issue.validation,\n    origin: info?.origin || \"value\",\n    message: issue.message,\n    input: issue.input,\n    requirement: issue?.requirement,\n    path: issue.path,\n    abortEarly: info?.abortEarly,\n    abortPipeEarly: info?.abortPipeEarly,\n    skipPipe: info?.skipPipe\n  };\n}\n\n// src/utils/pipeResult/utils/pipeInfo/pipeInfo.ts\nfunction pipeInfo(info, reason) {\n  return {\n    reason,\n    origin: info?.origin,\n    abortEarly: info?.abortEarly,\n    abortPipeEarly: info?.abortPipeEarly,\n    skipPipe: info?.skipPipe\n  };\n}\n\n// src/utils/pipeResult/pipeResult.ts\nfunction pipeResult(input, pipe, parseInfo, reason, issues) {\n  let info;\n  let output = input;\n  if (pipe?.length && !parseInfo?.skipPipe) {\n    for (const action of pipe) {\n      const result = action._parse(output);\n      if (result.issues) {\n        info = info || pipeInfo(parseInfo, reason);\n        for (const issueInfo of result.issues) {\n          const issue = pipeIssue(info, issueInfo);\n          issues ? issues.push(issue) : issues = [issue];\n        }\n        if (info.abortEarly || info.abortPipeEarly) {\n          break;\n        }\n      } else {\n        output = result.output;\n      }\n    }\n  }\n  return parseResult(true, output, issues);\n}\n\n// src/utils/pipeResult/pipeResultAsync.ts\nasync function pipeResultAsync(input, pipe, parseInfo, reason, issues) {\n  let info;\n  let output = input;\n  if (pipe?.length && !parseInfo?.skipPipe) {\n    for (const action of pipe) {\n      const result = await action._parse(output);\n      if (result.issues) {\n        info = info || pipeInfo(parseInfo, reason);\n        for (const issueInfo of result.issues) {\n          const issue = pipeIssue(info, issueInfo);\n          issues ? issues.push(issue) : issues = [issue];\n        }\n        if (info.abortEarly || info.abortPipeEarly) {\n          break;\n        }\n      } else {\n        output = result.output;\n      }\n    }\n  }\n  return parseResult(true, output, issues);\n}\n\n// src/utils/schemaIssue/schemaIssue.ts\nfunction schemaIssue(info, reason, validation, message, input, path, issues) {\n  return {\n    typed: false,\n    output: input,\n    issues: [\n      {\n        reason,\n        validation,\n        origin: info?.origin || \"value\",\n        message: errorMessage(message),\n        input,\n        path,\n        issues,\n        abortEarly: info?.abortEarly,\n        abortPipeEarly: info?.abortPipeEarly,\n        skipPipe: info?.skipPipe\n      }\n    ]\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, info) {\n  return typeof schema.fallback === \"function\" ? schema.fallback(info) : schema.fallback;\n}\n\n// src/methods/getFallback/getFallbackAsync.ts\nasync function getFallbackAsync(schema, info) {\n  return typeof schema.fallback === \"function\" ? await schema.fallback(info) : schema.fallback;\n}\n\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      return result.issues ? parseResult(true, getFallback(this, { input, issues: result.issues })) : result;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      return result.issues ? parseResult(\n        true,\n        await getFallbackAsync(this, { input, issues: result.issues })\n      ) : result;\n    }\n  };\n}\n\n// src/methods/forward/forward.ts\nfunction forward(validation, pathList) {\n  return {\n    ...validation,\n    _parse(input) {\n      const result = validation._parse(input);\n      if (result.issues) {\n        for (const issue of result.issues) {\n          let pathInput = input;\n          for (const key of pathList) {\n            const pathValue = pathInput[key];\n            issue.input = pathValue;\n            const pathItem = {\n              type: \"unknown\",\n              input: pathInput,\n              key,\n              value: pathValue\n            };\n            issue.path ? issue.path.push(pathItem) : issue.path = [pathItem];\n            if (!pathValue) {\n              break;\n            }\n            pathInput = pathValue;\n          }\n        }\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema) {\n  return typeof schema.default === \"function\" ? schema.default() : schema.default;\n}\n\n// src/methods/getDefault/getDefaultAsync.ts\nasync function getDefaultAsync(schema) {\n  return typeof schema.default === \"function\" ? await schema.default() : schema.default;\n}\n\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n  let defaults;\n  if (schema.default) {\n    defaults = getDefault(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      defaults = {};\n      for (const key in schema.entries) {\n        defaults[key] = getDefaults(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      defaults = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        defaults.push(getDefaults(schema.items[key]));\n      }\n    }\n  }\n  return defaults;\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n  let defaults;\n  if (schema.default) {\n    defaults = await getDefaultAsync(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      defaults = {};\n      for (const key in schema.entries) {\n        defaults[key] = await getDefaultsAsync(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      defaults = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        defaults.push(await getDefaultsAsync(schema.items[key]));\n      }\n    }\n  }\n  return defaults;\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n  let fallbacks;\n  if (schema.fallback) {\n    fallbacks = getFallback(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      fallbacks = {};\n      for (const key in schema.entries) {\n        fallbacks[key] = getFallbacks(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      fallbacks = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        fallbacks.push(getFallbacks(schema.items[key]));\n      }\n    }\n  }\n  return fallbacks;\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n  let fallbacks;\n  if (schema.fallback) {\n    fallbacks = await getFallbackAsync(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      fallbacks = {};\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, schema2]) => {\n          fallbacks[key] = await getFallbacksAsync(schema2);\n        })\n      );\n    } else if (schema.type === \"tuple\") {\n      fallbacks = await Promise.all(\n        schema.items.map((schema2) => getFallbacksAsync(schema2))\n      );\n    }\n  }\n  return fallbacks;\n}\n\n// src/methods/is/is.ts\nfunction is(schema, input, info) {\n  return !schema._parse(input, {\n    abortEarly: true,\n    skipPipe: info?.skipPipe\n  }).issues;\n}\n\n// src/schemas/any/any.ts\nfunction any(pipe) {\n  return {\n    type: \"any\",\n    async: false,\n    pipe,\n    _parse(input, info) {\n      return pipeResult(input, this.pipe, info, \"any\");\n    }\n  };\n}\n\n// src/schemas/any/anyAsync.ts\nfunction anyAsync(pipe) {\n  return {\n    type: \"any\",\n    async: true,\n    pipe,\n    async _parse(input, info) {\n      return pipeResultAsync(input, this.pipe, info, \"any\");\n    }\n  };\n}\n\n// src/schemas/array/array.ts\nfunction array(item, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"array\",\n    async: false,\n    item,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!Array.isArray(input)) {\n        return schemaIssue(info, \"type\", \"array\", this.message, input);\n      }\n      let typed = true;\n      let issues;\n      const output = [];\n      for (let key = 0; key < input.length; key++) {\n        const value2 = input[key];\n        const result = this.item._parse(value2, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"array\",\n            input,\n            key,\n            value: value2\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            typed = false;\n            break;\n          }\n        }\n        if (!result.typed) {\n          typed = false;\n        }\n        output.push(result.output);\n      }\n      if (typed) {\n        return pipeResult(\n          output,\n          this.pipe,\n          info,\n          \"array\",\n          issues\n        );\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"array\",\n    async: true,\n    item,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!Array.isArray(input)) {\n        return schemaIssue(info, \"type\", \"array\", this.message, input);\n      }\n      let typed = true;\n      let issues;\n      const output = [];\n      await Promise.all(\n        input.map(async (value2, key) => {\n          if (!(info?.abortEarly && issues)) {\n            const result = await this.item._parse(value2, info);\n            if (!(info?.abortEarly && issues)) {\n              if (result.issues) {\n                const pathItem = {\n                  type: \"array\",\n                  input,\n                  key,\n                  value: value2\n                };\n                for (const issue of result.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  issues?.push(issue);\n                }\n                if (!issues) {\n                  issues = result.issues;\n                }\n                if (info?.abortEarly) {\n                  typed = false;\n                  throw null;\n                }\n              }\n              if (!result.typed) {\n                typed = false;\n              }\n              output[key] = result.output;\n            }\n          }\n        })\n      ).catch(() => null);\n      if (typed) {\n        return pipeResultAsync(\n          output,\n          this.pipe,\n          info,\n          \"array\",\n          issues\n        );\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\nfunction bigint(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"bigint\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (typeof input !== \"bigint\") {\n        return schemaIssue(info, \"type\", \"bigint\", this.message, input);\n      }\n      return pipeResult(input, this.pipe, info, \"bigint\");\n    }\n  };\n}\n\n// src/schemas/bigint/bigintAsync.ts\nfunction bigintAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"bigint\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (typeof input !== \"bigint\") {\n        return schemaIssue(info, \"type\", \"bigint\", this.message, input);\n      }\n      return pipeResultAsync(input, this.pipe, info, \"bigint\");\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\nfunction blob(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"blob\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof Blob)) {\n        return schemaIssue(info, \"type\", \"blob\", this.message, input);\n      }\n      return pipeResult(input, this.pipe, info, \"blob\");\n    }\n  };\n}\n\n// src/schemas/blob/blobAsync.ts\nfunction blobAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"blob\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof Blob)) {\n        return schemaIssue(info, \"type\", \"blob\", this.message, input);\n      }\n      return pipeResultAsync(input, this.pipe, info, \"blob\");\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\nfunction boolean(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"boolean\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (typeof input !== \"boolean\") {\n        return schemaIssue(info, \"type\", \"boolean\", this.message, input);\n      }\n      return pipeResult(input, this.pipe, info, \"boolean\");\n    }\n  };\n}\n\n// src/schemas/boolean/booleanAsync.ts\nfunction booleanAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"boolean\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (typeof input !== \"boolean\") {\n        return schemaIssue(info, \"type\", \"boolean\", this.message, input);\n      }\n      return pipeResultAsync(input, this.pipe, info, \"boolean\");\n    }\n  };\n}\n\n// src/schemas/date/date.ts\nfunction date(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"date\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof Date) || isNaN(input.getTime())) {\n        return schemaIssue(info, \"type\", \"date\", this.message, input);\n      }\n      return pipeResult(input, this.pipe, info, \"date\");\n    }\n  };\n}\n\n// src/schemas/date/dateAsync.ts\nfunction dateAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"date\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof Date) || isNaN(input.getTime())) {\n        return schemaIssue(info, \"type\", \"date\", this.message, input);\n      }\n      return pipeResultAsync(input, this.pipe, info, \"date\");\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\nfunction enum_(enum_2, message = \"Invalid type\") {\n  return {\n    type: \"enum\",\n    async: false,\n    enum: enum_2,\n    message,\n    _parse(input, info) {\n      if (!Object.values(this.enum).includes(input)) {\n        return schemaIssue(info, \"type\", \"enum\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar nativeEnum = enum_;\n\n// src/schemas/enum/enumAsync.ts\nfunction enumAsync(enum_2, message = \"Invalid type\") {\n  return {\n    type: \"enum\",\n    async: true,\n    enum: enum_2,\n    message,\n    async _parse(input, info) {\n      if (!Object.values(this.enum).includes(input)) {\n        return schemaIssue(info, \"type\", \"enum\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar nativeEnumAsync = enumAsync;\n\n// src/schemas/instance/instance.ts\nfunction instance(class_, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"instance\",\n    async: false,\n    class: class_,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof this.class)) {\n        return schemaIssue(info, \"type\", \"instance\", this.message, input);\n      }\n      return pipeResult(input, this.pipe, info, \"instance\");\n    }\n  };\n}\n\n// src/schemas/instance/instanceAsync.ts\nfunction instanceAsync(class_, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"instance\",\n    async: true,\n    class: class_,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof this.class)) {\n        return schemaIssue(info, \"type\", \"instance\", this.message, input);\n      }\n      return pipeResultAsync(input, this.pipe, info, \"instance\");\n    }\n  };\n}\n\n// src/schemas/intersect/utils/mergeOutputs/mergeOutputs.ts\nfunction mergeOutputs(output1, output2) {\n  if (typeof output1 === typeof output2) {\n    if (output1 === output2 || output1 instanceof Date && output2 instanceof Date && +output1 === +output2) {\n      return { output: output1 };\n    }\n    if (Array.isArray(output1) && Array.isArray(output2)) {\n      if (output1.length === output2.length) {\n        const array2 = [];\n        for (let index = 0; index < output1.length; index++) {\n          const result = mergeOutputs(output1[index], output2[index]);\n          if (result.invalid) {\n            return result;\n          }\n          array2.push(result.output);\n        }\n        return { output: array2 };\n      }\n      return { invalid: true };\n    }\n    if (output1 && output2 && output1.constructor === Object && output2.constructor === Object) {\n      const object2 = { ...output1, ...output2 };\n      for (const key in output1) {\n        if (key in output2) {\n          const result = mergeOutputs(output1[key], output2[key]);\n          if (result.invalid) {\n            return result;\n          }\n          object2[key] = result.output;\n        }\n      }\n      return { output: object2 };\n    }\n  }\n  return { invalid: true };\n}\n\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"intersect\",\n    async: false,\n    options,\n    message,\n    pipe,\n    _parse(input, info) {\n      let typed = true;\n      let issues;\n      let output;\n      const outputs = [];\n      for (const schema of this.options) {\n        const result = schema._parse(input, info);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            typed = false;\n            break;\n          }\n        }\n        if (!result.typed) {\n          typed = false;\n        }\n        outputs.push(result.output);\n      }\n      if (typed) {\n        output = outputs[0];\n        for (let index = 1; index < outputs.length; index++) {\n          const result = mergeOutputs(output, outputs[index]);\n          if (result.invalid) {\n            return schemaIssue(info, \"type\", \"intersect\", this.message, input);\n          }\n          output = result.output;\n        }\n        return pipeResult(output, this.pipe, info, \"intersect\", issues);\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\nvar intersection = intersect;\n\n// src/schemas/literal/literal.ts\nfunction literal(literal2, message = \"Invalid type\") {\n  return {\n    type: \"literal\",\n    async: false,\n    literal: literal2,\n    message,\n    _parse(input, info) {\n      if (input !== this.literal) {\n        return schemaIssue(info, \"type\", \"literal\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\n\n// src/schemas/literal/literalAsync.ts\nfunction literalAsync(literal2, message = \"Invalid type\") {\n  return {\n    type: \"literal\",\n    async: true,\n    literal: literal2,\n    message,\n    async _parse(input, info) {\n      if (input !== this.literal) {\n        return schemaIssue(info, \"type\", \"literal\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\n\n// src/schemas/map/map.ts\nfunction map(key, value2, arg3, arg4) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg3, arg4);\n  return {\n    type: \"map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof Map)) {\n        return schemaIssue(info, \"type\", \"map\", this.message, input);\n      }\n      let typed = true;\n      let issues;\n      const output = /* @__PURE__ */ new Map();\n      for (const [inputKey, inputValue] of input.entries()) {\n        let pathItem;\n        const keyResult = this.key._parse(inputKey, {\n          origin: \"key\",\n          abortEarly: info?.abortEarly,\n          abortPipeEarly: info?.abortPipeEarly,\n          skipPipe: info?.skipPipe\n        });\n        if (keyResult.issues) {\n          pathItem = {\n            type: \"map\",\n            input,\n            key: inputKey,\n            value: inputValue\n          };\n          for (const issue of keyResult.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = keyResult.issues;\n          }\n          if (info?.abortEarly) {\n            typed = false;\n            break;\n          }\n        }\n        const valueResult = this.value._parse(inputValue, info);\n        if (valueResult.issues) {\n          pathItem = pathItem || {\n            type: \"map\",\n            input,\n            key: inputKey,\n            value: inputValue\n          };\n          for (const issue of valueResult.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = valueResult.issues;\n          }\n          if (info?.abortEarly) {\n            typed = false;\n            break;\n          }\n        }\n        if (!keyResult.typed || !valueResult.typed) {\n          typed = false;\n        }\n        output.set(keyResult.output, valueResult.output);\n      }\n      if (typed) {\n        return pipeResult(output, this.pipe, info, \"map\", issues);\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, arg3, arg4) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg3, arg4);\n  return {\n    type: \"map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof Map)) {\n        return schemaIssue(info, \"type\", \"map\", this.message, input);\n      }\n      let typed = true;\n      let issues;\n      const output = /* @__PURE__ */ new Map();\n      await Promise.all(\n        Array.from(input.entries()).map(async ([inputKey, inputValue]) => {\n          let pathItem;\n          const [keyResult, valueResult] = await Promise.all(\n            [\n              { schema: this.key, value: inputKey, origin: \"key\" },\n              { schema: this.value, value: inputValue, origin: \"value\" }\n            ].map(async ({ schema, value: value3, origin }) => {\n              if (!(info?.abortEarly && issues)) {\n                const result = await schema._parse(value3, {\n                  origin,\n                  abortEarly: info?.abortEarly,\n                  abortPipeEarly: info?.abortPipeEarly,\n                  skipPipe: info?.skipPipe\n                });\n                if (!(info?.abortEarly && issues)) {\n                  if (result.issues) {\n                    pathItem = pathItem || {\n                      type: \"map\",\n                      input,\n                      key: inputKey,\n                      value: inputValue\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (info?.abortEarly) {\n                      throw null;\n                    }\n                  }\n                  return result;\n                }\n              }\n            })\n          ).catch(() => []);\n          if (!keyResult?.typed || !valueResult?.typed) {\n            typed = false;\n          }\n          if (keyResult && valueResult) {\n            output.set(keyResult.output, valueResult.output);\n          }\n        })\n      );\n      if (typed) {\n        return pipeResultAsync(output, this.pipe, info, \"map\", issues);\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\nfunction nan(message = \"Invalid type\") {\n  return {\n    type: \"nan\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (!Number.isNaN(input)) {\n        return schemaIssue(info, \"type\", \"nan\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\n\n// src/schemas/nan/nanAsync.ts\nfunction nanAsync(message = \"Invalid type\") {\n  return {\n    type: \"nan\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (!Number.isNaN(input)) {\n        return schemaIssue(info, \"type\", \"nan\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\n\n// src/schemas/never/never.ts\nfunction never(message = \"Invalid type\") {\n  return {\n    type: \"never\",\n    async: false,\n    message,\n    _parse(input, info) {\n      return schemaIssue(info, \"type\", \"never\", this.message, input);\n    }\n  };\n}\n\n// src/schemas/never/neverAsync.ts\nfunction neverAsync(message = \"Invalid type\") {\n  return {\n    type: \"never\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      return schemaIssue(info, \"type\", \"never\", this.message, input);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_nullable\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, info) {\n      if (input === null) {\n        return schemaIssue(info, \"type\", \"non_nullable\", this.message, input);\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_nullable\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, info) {\n      if (input === null) {\n        return schemaIssue(info, \"type\", \"non_nullable\", this.message, input);\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_nullish\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, info) {\n      if (input === null || input === void 0) {\n        return schemaIssue(info, \"type\", \"non_nullish\", this.message, input);\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_nullish\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, info) {\n      if (input === null || input === void 0) {\n        return schemaIssue(info, \"type\", \"non_nullish\", this.message, input);\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_optional\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, info) {\n      if (input === void 0) {\n        return schemaIssue(info, \"type\", \"non_optional\", this.message, input);\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_optional\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, info) {\n      if (input === void 0) {\n        return schemaIssue(info, \"type\", \"non_optional\", this.message, input);\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, default_) {\n  return {\n    type: \"nullable\",\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, info) {\n      if (input === null) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return parseResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, default_) {\n  return {\n    type: \"nullable\",\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, info) {\n      if (input === null) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return parseResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, default_) {\n  return {\n    type: \"nullish\",\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, info) {\n      if (input === null || input === void 0) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return parseResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, default_) {\n  return {\n    type: \"nullish\",\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, info) {\n      if (input === null || input === void 0) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return parseResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/null/null.ts\nfunction null_(message = \"Invalid type\") {\n  return {\n    type: \"null\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (input !== null) {\n        return schemaIssue(info, \"type\", \"null\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar nullType = null_;\n\n// src/schemas/null/nullAsync.ts\nfunction nullAsync(message = \"Invalid type\") {\n  return {\n    type: \"null\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (input !== null) {\n        return schemaIssue(info, \"type\", \"null\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar nullTypeAsync = nullAsync;\n\n// src/schemas/number/number.ts\nfunction number(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"number\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (typeof input !== \"number\" || isNaN(input)) {\n        return schemaIssue(info, \"type\", \"number\", this.message, input);\n      }\n      return pipeResult(input, this.pipe, info, \"number\");\n    }\n  };\n}\n\n// src/schemas/number/numberAsync.ts\nfunction numberAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"number\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (typeof input !== \"number\" || isNaN(input)) {\n        return schemaIssue(info, \"type\", \"number\", this.message, input);\n      }\n      return pipeResultAsync(input, this.pipe, info, \"number\");\n    }\n  };\n}\n\n// src/schemas/object/object.ts\nfunction object(entries, arg2, arg3, arg4) {\n  const [rest, message = \"Invalid type\", pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  let cachedEntries;\n  return {\n    type: \"object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return schemaIssue(info, \"type\", \"object\", this.message, input);\n      }\n      cachedEntries = cachedEntries || Object.entries(this.entries);\n      let typed = true;\n      let issues;\n      const output = {};\n      for (const [key, schema] of cachedEntries) {\n        const value2 = input[key];\n        const result = schema._parse(value2, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"object\",\n            input,\n            key,\n            value: value2\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            typed = false;\n            break;\n          }\n        }\n        if (!result.typed) {\n          typed = false;\n        }\n        if (result.output !== void 0 || key in input) {\n          output[key] = result.output;\n        }\n      }\n      if (this.rest && !(info?.abortEarly && issues)) {\n        for (const key in input) {\n          if (!(key in this.entries)) {\n            const value2 = input[key];\n            const result = this.rest._parse(value2, info);\n            if (result.issues) {\n              const pathItem = {\n                type: \"object\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of result.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                issues?.push(issue);\n              }\n              if (!issues) {\n                issues = result.issues;\n              }\n              if (info?.abortEarly) {\n                typed = false;\n                break;\n              }\n            }\n            if (!result.typed) {\n              typed = false;\n            }\n            output[key] = result.output;\n          }\n        }\n      }\n      if (typed) {\n        return pipeResult(\n          output,\n          this.pipe,\n          info,\n          \"object\",\n          issues\n        );\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, arg2, arg3, arg4) {\n  const [rest, message = \"Invalid type\", pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  let cachedEntries;\n  return {\n    type: \"object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return schemaIssue(info, \"type\", \"object\", this.message, input);\n      }\n      cachedEntries = cachedEntries || Object.entries(this.entries);\n      let typed = true;\n      let issues;\n      const output = {};\n      await Promise.all([\n        Promise.all(\n          cachedEntries.map(async ([key, schema]) => {\n            if (!(info?.abortEarly && issues)) {\n              const value2 = input[key];\n              const result = await schema._parse(value2, info);\n              if (!(info?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"object\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (info?.abortEarly) {\n                    typed = false;\n                    throw null;\n                  }\n                }\n                if (!result.typed) {\n                  typed = false;\n                }\n                if (result.output !== void 0 || key in input) {\n                  output[key] = result.output;\n                }\n              }\n            }\n          })\n        ),\n        this.rest && Promise.all(\n          Object.entries(input).map(async ([key, value2]) => {\n            if (!(info?.abortEarly && issues)) {\n              if (!(key in this.entries)) {\n                const result = await this.rest._parse(value2, info);\n                if (!(info?.abortEarly && issues)) {\n                  if (result.issues) {\n                    const pathItem = {\n                      type: \"object\",\n                      input,\n                      key,\n                      value: value2\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (info?.abortEarly) {\n                      typed = false;\n                      throw null;\n                    }\n                  }\n                  if (!result.typed) {\n                    typed = false;\n                  }\n                  output[key] = result.output;\n                }\n              }\n            }\n          })\n        )\n      ]).catch(() => null);\n      if (typed) {\n        return pipeResultAsync(\n          output,\n          this.pipe,\n          info,\n          \"object\",\n          issues\n        );\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, default_) {\n  return {\n    type: \"optional\",\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, info) {\n      if (input === void 0) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return parseResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, default_) {\n  return {\n    type: \"optional\",\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, info) {\n      if (input === void 0) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return parseResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message = \"Invalid type\") {\n  return {\n    type: \"picklist\",\n    async: false,\n    options,\n    message,\n    _parse(input, info) {\n      if (!this.options.includes(input)) {\n        return schemaIssue(info, \"type\", \"picklist\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar enumType = picklist;\n\n// src/schemas/picklist/picklistAsync.ts\nfunction picklistAsync(options, message = \"Invalid type\") {\n  return {\n    type: \"picklist\",\n    async: true,\n    options,\n    message,\n    async _parse(input, info) {\n      if (!this.options.includes(input)) {\n        return schemaIssue(info, \"type\", \"picklist\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar enumTypeAsync = picklistAsync;\n\n// src/schemas/string/string.ts\nfunction string(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"string\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (typeof input !== \"string\") {\n        return schemaIssue(info, \"type\", \"string\", this.message, input);\n      }\n      return pipeResult(input, this.pipe, info, \"string\");\n    }\n  };\n}\n\n// src/schemas/string/stringAsync.ts\nfunction stringAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"string\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (typeof input !== \"string\") {\n        return schemaIssue(info, \"type\", \"string\", this.message, input);\n      }\n      return pipeResultAsync(input, this.pipe, info, \"string\");\n    }\n  };\n}\n\n// src/schemas/record/utils/recordArgs/recordArgs.ts\nfunction recordArgs(arg1, arg2, arg3, arg4) {\n  if (typeof arg2 === \"object\" && !Array.isArray(arg2)) {\n    const [message2, pipe2] = defaultArgs(arg3, arg4);\n    return [arg1, arg2, message2, pipe2];\n  }\n  const [message, pipe] = defaultArgs(\n    arg2,\n    arg3\n  );\n  return [string(), arg1, message, pipe];\n}\n\n// src/schemas/record/values.ts\nvar BLOCKED_KEYS = [\"__proto__\", \"prototype\", \"constructor\"];\n\n// src/schemas/record/record.ts\nfunction record(arg1, arg2, arg3, arg4) {\n  const [key, value2, message = \"Invalid type\", pipe] = recordArgs(arg1, arg2, arg3, arg4);\n  return {\n    type: \"record\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return schemaIssue(info, \"type\", \"record\", this.message, input);\n      }\n      let typed = true;\n      let issues;\n      const output = {};\n      for (const [inputKey, inputValue] of Object.entries(input)) {\n        if (!BLOCKED_KEYS.includes(inputKey)) {\n          let pathItem;\n          const keyResult = this.key._parse(inputKey, {\n            origin: \"key\",\n            abortEarly: info?.abortEarly,\n            abortPipeEarly: info?.abortPipeEarly,\n            skipPipe: info?.skipPipe\n          });\n          if (keyResult.issues) {\n            pathItem = {\n              type: \"record\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyResult.issues) {\n              issue.path = [pathItem];\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = keyResult.issues;\n            }\n            if (info?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          const valueResult = this.value._parse(inputValue, info);\n          if (valueResult.issues) {\n            pathItem = pathItem || {\n              type: \"record\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueResult.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = valueResult.issues;\n            }\n            if (info?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          if (!keyResult.typed || !valueResult.typed) {\n            typed = false;\n          }\n          if (keyResult.typed) {\n            output[keyResult.output] = valueResult.output;\n          }\n        }\n      }\n      if (typed) {\n        return pipeResult(\n          output,\n          this.pipe,\n          info,\n          \"record\",\n          issues\n        );\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(arg1, arg2, arg3, arg4) {\n  const [key, value2, message = \"Invalid type\", pipe] = recordArgs(arg1, arg2, arg3, arg4);\n  return {\n    type: \"record\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return schemaIssue(info, \"type\", \"record\", this.message, input);\n      }\n      let typed = true;\n      let issues;\n      const output = {};\n      await Promise.all(\n        // Note: `Object.entries(...)` converts each key to a string\n        Object.entries(input).map(async ([inputKey, inputValue]) => {\n          if (!BLOCKED_KEYS.includes(inputKey)) {\n            let pathItem;\n            const [keyResult, valueResult] = await Promise.all(\n              [\n                { schema: this.key, value: inputKey, origin: \"key\" },\n                { schema: this.value, value: inputValue, origin: \"value\" }\n              ].map(async ({ schema, value: value3, origin }) => {\n                if (!(info?.abortEarly && issues)) {\n                  const result = await schema._parse(value3, {\n                    origin,\n                    abortEarly: info?.abortEarly,\n                    abortPipeEarly: info?.abortPipeEarly,\n                    skipPipe: info?.skipPipe\n                  });\n                  if (!(info?.abortEarly && issues)) {\n                    if (result.issues) {\n                      pathItem = pathItem || {\n                        type: \"record\",\n                        input,\n                        key: inputKey,\n                        value: inputValue\n                      };\n                      for (const issue of result.issues) {\n                        if (issue.path) {\n                          issue.path.unshift(pathItem);\n                        } else {\n                          issue.path = [pathItem];\n                        }\n                        issues?.push(issue);\n                      }\n                      if (!issues) {\n                        issues = result.issues;\n                      }\n                      if (info?.abortEarly) {\n                        throw null;\n                      }\n                    }\n                    return result;\n                  }\n                }\n              })\n            ).catch(() => []);\n            if (!keyResult?.typed || !valueResult?.typed) {\n              typed = false;\n            }\n            if (keyResult?.typed && valueResult) {\n              output[keyResult.output] = valueResult.output;\n            }\n          }\n        })\n      );\n      if (typed) {\n        return pipeResultAsync(\n          output,\n          this.pipe,\n          info,\n          \"record\",\n          issues\n        );\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/recursive/recursive.ts\nfunction recursive(getter) {\n  return {\n    type: \"recursive\",\n    async: false,\n    getter,\n    _parse(input, info) {\n      return this.getter()._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/recursive/recursiveAsync.ts\nfunction recursiveAsync(getter) {\n  return {\n    type: \"recursive\",\n    async: true,\n    getter,\n    async _parse(input, info) {\n      return this.getter()._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/set/set.ts\nfunction set(value2, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"set\",\n    async: false,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof Set)) {\n        return schemaIssue(info, \"type\", \"set\", this.message, input);\n      }\n      let key = 0;\n      let typed = true;\n      let issues;\n      const output = /* @__PURE__ */ new Set();\n      for (const inputValue of input) {\n        const result = this.value._parse(inputValue, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"set\",\n            input,\n            key,\n            value: inputValue\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            typed = false;\n            break;\n          }\n        }\n        if (!result.typed) {\n          typed = false;\n        }\n        output.add(result.output);\n        key++;\n      }\n      if (typed) {\n        return pipeResult(output, this.pipe, info, \"set\", issues);\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"set\",\n    async: true,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof Set)) {\n        return schemaIssue(info, \"type\", \"set\", this.message, input);\n      }\n      let typed = true;\n      let issues;\n      const output = /* @__PURE__ */ new Set();\n      await Promise.all(\n        Array.from(input.values()).map(async (inputValue, key) => {\n          if (!(info?.abortEarly && issues)) {\n            const result = await this.value._parse(inputValue, info);\n            if (!(info?.abortEarly && issues)) {\n              if (result.issues) {\n                const pathItem = {\n                  type: \"set\",\n                  input,\n                  key,\n                  value: inputValue\n                };\n                for (const issue of result.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  issues?.push(issue);\n                }\n                if (!issues) {\n                  issues = result.issues;\n                }\n                if (info?.abortEarly) {\n                  typed = false;\n                  throw null;\n                }\n              }\n              if (!result.typed) {\n                typed = false;\n              }\n              output.add(result.output);\n            }\n          }\n        })\n      ).catch(() => null);\n      if (typed) {\n        return pipeResultAsync(output, this.pipe, info, \"set\", issues);\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/special/special.ts\nfunction special(check, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"special\",\n    async: false,\n    check,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!this.check(input)) {\n        return schemaIssue(info, \"type\", \"special\", this.message, input);\n      }\n      return pipeResult(input, this.pipe, info, \"special\");\n    }\n  };\n}\n\n// src/schemas/special/specialAsync.ts\nfunction specialAsync(check, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"special\",\n    async: true,\n    check,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!await this.check(input)) {\n        return schemaIssue(info, \"type\", \"special\", this.message, input);\n      }\n      return pipeResultAsync(input, this.pipe, info, \"special\");\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\nfunction symbol(message = \"Invalid type\") {\n  return {\n    type: \"symbol\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (typeof input !== \"symbol\") {\n        return schemaIssue(info, \"type\", \"symbol\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\n\n// src/schemas/symbol/symbolAsync.ts\nfunction symbolAsync(message = \"Invalid type\") {\n  return {\n    type: \"symbol\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (typeof input !== \"symbol\") {\n        return schemaIssue(info, \"type\", \"symbol\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, arg2, arg3, arg4) {\n  const [rest, message = \"Invalid type\", pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return {\n    type: \"tuple\",\n    async: false,\n    items,\n    rest,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!Array.isArray(input) || this.items.length > input.length) {\n        return schemaIssue(info, \"type\", \"tuple\", this.message, input);\n      }\n      let typed = true;\n      let issues;\n      const output = [];\n      for (let key = 0; key < this.items.length; key++) {\n        const value2 = input[key];\n        const result = this.items[key]._parse(value2, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"tuple\",\n            input,\n            key,\n            value: value2\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            typed = false;\n            break;\n          }\n        }\n        if (!result.typed) {\n          typed = false;\n        }\n        output[key] = result.output;\n      }\n      if (this.rest && !(info?.abortEarly && issues)) {\n        for (let key = this.items.length; key < input.length; key++) {\n          const value2 = input[key];\n          const result = this.rest._parse(value2, info);\n          if (result.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of result.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = result.issues;\n            }\n            if (info?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          if (!result.typed) {\n            typed = false;\n          }\n          output[key] = result.output;\n        }\n      }\n      if (typed) {\n        return pipeResult(\n          output,\n          this.pipe,\n          info,\n          \"tuple\",\n          issues\n        );\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, arg2, arg3, arg4) {\n  const [rest, message = \"Invalid type\", pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return {\n    type: \"tuple\",\n    async: true,\n    items,\n    rest,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!Array.isArray(input) || this.items.length > input.length) {\n        return schemaIssue(info, \"type\", \"tuple\", this.message, input);\n      }\n      let typed = true;\n      let issues;\n      const output = [];\n      await Promise.all([\n        // Parse schema of each tuple item\n        Promise.all(\n          this.items.map(async (schema, key) => {\n            if (!(info?.abortEarly && issues)) {\n              const value2 = input[key];\n              const result = await schema._parse(value2, info);\n              if (!(info?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"tuple\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (info?.abortEarly) {\n                    typed = false;\n                    throw null;\n                  }\n                }\n                if (!result.typed) {\n                  typed = false;\n                }\n                output[key] = result.output;\n              }\n            }\n          })\n        ),\n        // If necessary parse schema of each rest item\n        this.rest && Promise.all(\n          input.slice(this.items.length).map(async (value2, index) => {\n            if (!(info?.abortEarly && issues)) {\n              const key = this.items.length + index;\n              const result = await this.rest._parse(value2, info);\n              if (!(info?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"tuple\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (info?.abortEarly) {\n                    typed = false;\n                    throw null;\n                  }\n                }\n                if (!result.typed) {\n                  typed = false;\n                }\n                output[key] = result.output;\n              }\n            }\n          })\n        )\n      ]).catch(() => null);\n      if (typed) {\n        return pipeResultAsync(\n          output,\n          this.pipe,\n          info,\n          \"tuple\",\n          issues\n        );\n      }\n      return parseResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message = \"Invalid type\") {\n  return {\n    type: \"undefined\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return schemaIssue(info, \"type\", \"undefined\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar undefinedType = undefined_;\n\n// src/schemas/undefined/undefinedAsync.ts\nfunction undefinedAsync(message = \"Invalid type\") {\n  return {\n    type: \"undefined\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return schemaIssue(info, \"type\", \"undefined\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar undefinedTypeAsync = undefinedAsync;\n\n// src/schemas/union/union.ts\nfunction union(options, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"union\",\n    async: false,\n    options,\n    message,\n    pipe,\n    _parse(input, info) {\n      let issues;\n      let output;\n      for (const schema of this.options) {\n        const result = schema._parse(input, info);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n        } else {\n          output = [result.output];\n          break;\n        }\n      }\n      if (output) {\n        return pipeResult(output[0], this.pipe, info, \"union\");\n      }\n      return schemaIssue(\n        info,\n        \"type\",\n        \"union\",\n        this.message,\n        input,\n        void 0,\n        issues\n      );\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"union\",\n    async: true,\n    options,\n    message,\n    pipe,\n    async _parse(input, info) {\n      let issues;\n      let output;\n      for (const schema of this.options) {\n        const result = await schema._parse(input, info);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n        } else {\n          output = [result.output];\n          break;\n        }\n      }\n      if (output) {\n        return pipeResultAsync(output[0], this.pipe, info, \"union\");\n      }\n      return schemaIssue(\n        info,\n        \"type\",\n        \"union\",\n        this.message,\n        input,\n        void 0,\n        issues\n      );\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\nfunction unknown(pipe) {\n  return {\n    type: \"unknown\",\n    async: false,\n    pipe,\n    _parse(input, info) {\n      return pipeResult(input, this.pipe, info, \"unknown\");\n    }\n  };\n}\n\n// src/schemas/unknown/unknownAsync.ts\nfunction unknownAsync(pipe) {\n  return {\n    type: \"unknown\",\n    async: true,\n    pipe,\n    async _parse(input, info) {\n      return pipeResultAsync(input, this.pipe, info, \"unknown\");\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\nfunction variant(key, options, arg3, arg4) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg3, arg4);\n  return {\n    type: \"variant\",\n    async: false,\n    key,\n    options,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return schemaIssue(info, \"type\", \"variant\", this.message, input);\n      }\n      if (this.key in input) {\n        let issues;\n        let output;\n        const parseOptions = (options2) => {\n          for (const schema of options2) {\n            if (schema.type === \"object\") {\n              const keyResult = schema.entries[this.key]._parse(\n                input[this.key],\n                info\n              );\n              if (!keyResult.issues) {\n                const dataResult = schema._parse(input, info);\n                if (dataResult.issues) {\n                  issues = dataResult.issues;\n                } else {\n                  output = [dataResult.output];\n                  break;\n                }\n              }\n            } else if (schema.type === \"variant\") {\n              parseOptions(schema.options);\n              if (output) {\n                break;\n              }\n            }\n          }\n        };\n        parseOptions(this.options);\n        if (output) {\n          return pipeResult(output[0], this.pipe, info, \"variant\");\n        }\n        if (issues) {\n          return parseResult(false, output, issues);\n        }\n      }\n      return schemaIssue(info, \"type\", \"variant\", this.message, input, [\n        {\n          type: \"object\",\n          input,\n          key: this.key,\n          value: void 0\n        }\n      ]);\n    }\n  };\n}\nvar discriminatedUnion = variant;\n\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, arg3, arg4) {\n  const [message = \"Invalid type\", pipe] = defaultArgs(arg3, arg4);\n  return {\n    type: \"variant\",\n    async: true,\n    key,\n    options,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return schemaIssue(info, \"type\", \"variant\", this.message, input);\n      }\n      if (this.key in input) {\n        let issues;\n        let output;\n        const parseOptions = async (options2) => {\n          for (const schema of options2) {\n            if (schema.type === \"object\") {\n              const keyResult = await schema.entries[this.key]._parse(\n                input[this.key],\n                info\n              );\n              if (!keyResult.issues) {\n                const dataResult = await schema._parse(input, info);\n                if (dataResult.issues) {\n                  issues = dataResult.issues;\n                } else {\n                  output = [dataResult.output];\n                  break;\n                }\n              }\n            } else if (schema.type === \"variant\") {\n              await parseOptions(schema.options);\n              if (output) {\n                break;\n              }\n            }\n          }\n        };\n        await parseOptions(this.options);\n        if (output) {\n          return pipeResultAsync(output[0], this.pipe, info, \"variant\");\n        }\n        if (issues) {\n          return parseResult(false, output, issues);\n        }\n      }\n      return schemaIssue(info, \"type\", \"variant\", this.message, input, [\n        {\n          type: \"object\",\n          input,\n          key: this.key,\n          value: void 0\n        }\n      ]);\n    }\n  };\n}\nvar discriminatedUnionAsync = variantAsync;\n\n// src/schemas/void/void.ts\nfunction void_(message = \"Invalid type\") {\n  return {\n    type: \"void\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return schemaIssue(info, \"type\", \"void\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar voidType = void_;\n\n// src/schemas/void/voidAsync.ts\nfunction voidAsync(message = \"Invalid type\") {\n  return {\n    type: \"void\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return schemaIssue(info, \"type\", \"void\", this.message, input);\n      }\n      return parseResult(true, input);\n    }\n  };\n}\nvar voidTypeAsync = voidAsync;\n\n// src/methods/keyof/keyof.ts\nfunction keyof(schema) {\n  return picklist(\n    Object.keys(schema.entries)\n  );\n}\n\n// src/methods/merge/merge.ts\nfunction merge(schemas, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    schemas.reduce(\n      (entries, schema) => ({ ...entries, ...schema.entries }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/merge/mergeAsync.ts\nfunction mergeAsync(schemas, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    schemas.reduce(\n      (entries, schema) => ({ ...entries, ...schema.entries }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/omit/omit.ts\nfunction omit(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/omit/omitAsync.ts\nfunction omitAsync(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, info) {\n  const result = schema._parse(input, info);\n  if (result.issues) {\n    throw new ValiError(result.issues);\n  }\n  return result.output;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, info) {\n  const result = await schema._parse(input, info);\n  if (result.issues) {\n    throw new ValiError(result.issues);\n  }\n  return result.output;\n}\n\n// src/methods/partial/partial.ts\nfunction partial(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: optional(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: optionalAsync(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/passthrough/passthrough.ts\nfunction passthrough(schema) {\n  return {\n    ...schema,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      if (result.typed) {\n        result.output = { ...input, ...result.output };\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/passthrough/passthroughAsync.ts\nfunction passthroughAsync(schema) {\n  return {\n    ...schema,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      if (result.typed) {\n        result.output = { ...input, ...result.output };\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\nfunction pick(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/pick/pickAsync.ts\nfunction pickAsync(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: nonOptional(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: nonOptionalAsync(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, info) {\n  const result = schema._parse(input, info);\n  return {\n    typed: result.typed,\n    success: !result.issues,\n    data: result.output,\n    output: result.output,\n    error: result.issues && new ValiError(result.issues),\n    issues: result.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, info) {\n  const result = await schema._parse(input, info);\n  return {\n    typed: result.typed,\n    success: !result.issues,\n    data: result.output,\n    output: result.output,\n    error: result.issues && new ValiError(result.issues),\n    issues: result.issues\n  };\n}\n\n// src/methods/strict/strict.ts\nfunction strict(schema, message = \"Invalid keys\") {\n  return {\n    ...schema,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      return !result.issues && Object.keys(input).some((key) => !(key in schema.entries)) ? schemaIssue(info, \"object\", \"strict\", message, input) : result;\n    }\n  };\n}\n\n// src/methods/strict/strictAsync.ts\nfunction strictAsync(schema, message = \"Invalid keys\") {\n  return {\n    ...schema,\n    message,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      return !result.issues && Object.keys(input).some((key) => !(key in schema.entries)) ? schemaIssue(info, \"object\", \"strict\", message, input) : result;\n    }\n  };\n}\n\n// src/methods/strip/strip.ts\nfunction strip(schema) {\n  let cachedKeys;\n  return {\n    ...schema,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      if (result.typed) {\n        cachedKeys = cachedKeys || Object.keys(schema.entries);\n        const output = {};\n        for (const key of cachedKeys) {\n          output[key] = result.output[key];\n        }\n        result.output = output;\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/strip/stripAsync.ts\nfunction stripAsync(schema) {\n  let cachedKeys;\n  return {\n    ...schema,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      if (result.typed) {\n        cachedKeys = cachedKeys || Object.keys(schema.entries);\n        const output = {};\n        for (const key of cachedKeys) {\n          output[key] = result.output[key];\n        }\n        result.output = output;\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/transform/transform.ts\nfunction transform(schema, action, arg1) {\n  return {\n    ...schema,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      if (result.typed) {\n        result.output = action(result.output, { issues: result.issues });\n        if (result.issues || !arg1) {\n          return result;\n        }\n        if (Array.isArray(arg1)) {\n          return pipeResult(result.output, arg1, info, typeof result.output);\n        }\n        return arg1._parse(result.output, info);\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/transform/transformAsync.ts\nfunction transformAsync(schema, action, arg1) {\n  return {\n    ...schema,\n    async: true,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      if (result.typed) {\n        result.output = await action(result.output, { issues: result.issues });\n        if (result.issues || !arg1) {\n          return result;\n        }\n        if (Array.isArray(arg1)) {\n          return pipeResultAsync(\n            result.output,\n            arg1,\n            info,\n            typeof result.output\n          );\n        }\n        return arg1._parse(result.output, info);\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\n\n// src/methods/withDefault/withDefault.ts\nfunction withDefault(schema, value2) {\n  return {\n    ...schema,\n    _parse(input, info) {\n      return schema._parse(\n        input === void 0 ? typeof value2 === \"function\" ? value2() : value2 : input,\n        info\n      );\n    }\n  };\n}\nvar useDefault = withDefault;\n\n// src/regex.ts\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[A-Z\\d]{2}(?:[A-Z\\d]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\nvar HEXADECIMAL_REGEX = /^(0h|0x)?[\\da-f]+$/iu;\nvar HEX_COLOR_REGEX = /^#([\\da-f]{3}|[\\da-f]{4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\nvar IMEI_REGEX = /^\\d{2}(?:[ /|-]?\\d{6}){2}[ /|-]?\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}\\.\\d{3}Z$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar OCTAL_REGEX = /^(0o)?[0-7]+$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/transformations/toCustom/toCustom.ts\nfunction toCustom(action) {\n  return {\n    type: \"to_custom\",\n    async: false,\n    _parse(input) {\n      return actionOutput(action(input));\n    }\n  };\n}\n\n// src/transformations/toCustom/toCustomAsync.ts\nfunction toCustomAsync(action) {\n  return {\n    type: \"to_custom\",\n    async: true,\n    async _parse(input) {\n      return actionOutput(await action(input));\n    }\n  };\n}\n\n// src/transformations/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n  return {\n    type: \"to_lower_case\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.toLocaleLowerCase());\n    }\n  };\n}\n\n// src/transformations/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n  return {\n    type: \"to_max_value\",\n    async: false,\n    requirement,\n    _parse(input) {\n      return actionOutput(input > this.requirement ? this.requirement : input);\n    }\n  };\n}\n\n// src/transformations/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n  return {\n    type: \"to_min_value\",\n    async: false,\n    requirement,\n    _parse(input) {\n      return actionOutput(input < this.requirement ? this.requirement : input);\n    }\n  };\n}\n\n// src/transformations/toTrimmed/toTrimmed.ts\nfunction toTrimmed() {\n  return {\n    type: \"to_trimmed\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.trim());\n    }\n  };\n}\n\n// src/transformations/toTrimmedEnd/toTrimmedEnd.ts\nfunction toTrimmedEnd() {\n  return {\n    type: \"to_trimmed_end\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.trimEnd());\n    }\n  };\n}\n\n// src/transformations/toTrimmedStart/toTrimmedStart.ts\nfunction toTrimmedStart() {\n  return {\n    type: \"to_trimmed_start\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.trimStart());\n    }\n  };\n}\n\n// src/transformations/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n  return {\n    type: \"to_upper_case\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.toUpperCase());\n    }\n  };\n}\n\n// src/validations/bic/bic.ts\nfunction bic(message = \"Invalid BIC\") {\n  return {\n    type: \"bic\",\n    async: false,\n    message,\n    requirement: BIC_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input.toUpperCase()) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/bytes/bytes.ts\nfunction bytes(requirement, message = \"Invalid byte length\") {\n  return {\n    type: \"bytes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return new TextEncoder().encode(input).length !== this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/creditCard/creditCard.ts\nvar SANITIZE_REGEX = /[- ]+/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  /^5[1-5]\\d{2}|(222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(6[27]\\d{14}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\nfunction creditCard(message = \"Invalid credit card\") {\n  return {\n    type: \"credit_card\",\n    async: false,\n    message,\n    requirement: (input) => {\n      const sanitized = input.replace(SANITIZE_REGEX, \"\");\n      return PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && isLuhnAlgo(sanitized);\n    },\n    _parse(input) {\n      return !this.requirement(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/cuid2/cuid2.ts\nfunction cuid2(message = \"Invalid Cuid2\") {\n  return {\n    type: \"cuid2\",\n    async: false,\n    message,\n    requirement: CUID2_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/custom/custom.ts\nfunction custom(requirement, message = \"Invalid input\") {\n  return {\n    type: \"custom\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !this.requirement(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/custom/customAsync.ts\nfunction customAsync(requirement, message = \"Invalid input\") {\n  return {\n    type: \"custom\",\n    async: true,\n    message,\n    requirement,\n    async _parse(input) {\n      return !await this.requirement(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/decimal/decimal.ts\nfunction decimal(message = \"Invalid decimal\") {\n  return {\n    type: \"decimal\",\n    async: false,\n    message,\n    requirement: DECIMAL_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/email/email.ts\nfunction email(message = \"Invalid email\") {\n  return {\n    type: \"email\",\n    async: false,\n    message,\n    requirement: EMAIL_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/emoji/emoji.ts\nfunction emoji(message = \"Invalid emoji\") {\n  return {\n    type: \"emoji\",\n    async: false,\n    message,\n    requirement: EMOJI_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/endsWith/endsWith.ts\nfunction endsWith(requirement, message = \"Invalid end\") {\n  return {\n    type: \"ends_with\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !input.endsWith(this.requirement) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/equal/equal.ts\nfunction equal(requirement, message = \"Invalid input\") {\n  return {\n    type: \"equal\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input !== this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/excludes/excludes.ts\nfunction excludes(requirement, message = \"Invalid content\") {\n  return {\n    type: \"excludes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.includes(this.requirement) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/finite/finite.ts\nfunction finite(message = \"Invalid finite number\") {\n  return {\n    type: \"finite\",\n    async: false,\n    message,\n    requirement: Number.isFinite,\n    _parse(input) {\n      return !this.requirement(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/hexadecimal/hexadecimal.ts\nfunction hexadecimal(message = \"Invalid hexadecimal\") {\n  return {\n    type: \"hexadecimal\",\n    async: false,\n    message,\n    requirement: HEXADECIMAL_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/hexColor/hexColor.ts\nfunction hexColor(message = \"Invalid hex color\") {\n  return {\n    type: \"hex_color\",\n    async: false,\n    message,\n    requirement: HEX_COLOR_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/imei/imei.ts\nfunction imei(message = \"Invalid IMEI\") {\n  return {\n    type: \"imei\",\n    async: false,\n    message,\n    requirement: [IMEI_REGEX, isLuhnAlgo],\n    _parse(input) {\n      return !this.requirement[0].test(input) || !this.requirement[1](input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/includes/includes.ts\nfunction includes(requirement, message = \"Invalid content\") {\n  return {\n    type: \"includes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !input.includes(requirement) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/integer/integer.ts\nfunction integer(message = \"Invalid integer\") {\n  return {\n    type: \"integer\",\n    async: false,\n    message,\n    requirement: Number.isInteger,\n    _parse(input) {\n      return !this.requirement(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/ip/ip.ts\nfunction ip(message = \"Invalid IP\") {\n  return {\n    type: \"ip\",\n    async: false,\n    message,\n    requirement: [IPV4_REGEX, IPV6_REGEX],\n    _parse(input) {\n      return !this.requirement[0].test(input) && !this.requirement[1].test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/ipv4/ipv4.ts\nfunction ipv4(message = \"Invalid IPv4\") {\n  return {\n    type: \"ipv4\",\n    async: false,\n    message,\n    requirement: IPV4_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/ipv6/ipv6.ts\nfunction ipv6(message = \"Invalid IPv6\") {\n  return {\n    type: \"ipv6\",\n    async: false,\n    message,\n    requirement: IPV6_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/isoDate/isoDate.ts\nfunction isoDate(message = \"Invalid date\") {\n  return {\n    type: \"iso_date\",\n    async: false,\n    message,\n    requirement: ISO_DATE_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message = \"Invalid date-time\") {\n  return {\n    type: \"iso_date_time\",\n    async: false,\n    message,\n    requirement: ISO_DATE_TIME_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/isoTime/isoTime.ts\nfunction isoTime(message = \"Invalid time\") {\n  return {\n    type: \"iso_time\",\n    async: false,\n    message,\n    requirement: ISO_TIME_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message = \"Invalid time second\") {\n  return {\n    type: \"iso_time_second\",\n    async: false,\n    message,\n    requirement: ISO_TIME_SECOND_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message = \"Invalid timestamp\") {\n  return {\n    type: \"iso_timestamp\",\n    async: false,\n    message,\n    requirement: ISO_TIMESTAMP_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/isoWeek/isoWeek.ts\nfunction isoWeek(message = \"Invalid week\") {\n  return {\n    type: \"iso_week\",\n    async: false,\n    message,\n    requirement: ISO_WEEK_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/length/length.ts\nfunction length(requirement, message = \"Invalid length\") {\n  return {\n    type: \"length\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.length !== this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/mac/mac.ts\nfunction mac(message = \"Invalid MAC\") {\n  return {\n    type: \"mac\",\n    async: false,\n    message,\n    requirement: [MAC48_REGEX, MAC64_REGEX],\n    _parse(input) {\n      return !this.requirement[0].test(input) && !this.requirement[1].test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/mac48/mac48.ts\nfunction mac48(message = \"Invalid 48 bit MAC\") {\n  return {\n    type: \"mac48\",\n    async: false,\n    message,\n    requirement: MAC48_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/mac64/mac64.ts\nfunction mac64(message = \"Invalid 64 bit MAC\") {\n  return {\n    type: \"mac64\",\n    async: false,\n    message,\n    requirement: MAC64_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message = \"Invalid byte length\") {\n  return {\n    type: \"max_bytes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return new TextEncoder().encode(input).length > this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/maxLength/maxLength.ts\nfunction maxLength(requirement, message = \"Invalid length\") {\n  return {\n    type: \"max_length\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.length > this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/maxSize/maxSize.ts\nfunction maxSize(requirement, message = \"Invalid size\") {\n  return {\n    type: \"max_size\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.size > this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/maxValue/maxValue.ts\nfunction maxValue(requirement, message = \"Invalid value\") {\n  return {\n    type: \"max_value\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input > this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\nvar maxRange = maxValue;\n\n// src/validations/minBytes/minBytes.ts\nfunction minBytes(requirement, message = \"Invalid byte length\") {\n  return {\n    type: \"min_bytes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return new TextEncoder().encode(input).length < this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/mimeType/mimeType.ts\nfunction mimeType(requirement, message = \"Invalid MIME type\") {\n  return {\n    type: \"mime_type\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !this.requirement.includes(input.type) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/minLength/minLength.ts\nfunction minLength(requirement, message = \"Invalid length\") {\n  return {\n    type: \"min_length\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.length < this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/minSize/minSize.ts\nfunction minSize(requirement, message = \"Invalid size\") {\n  return {\n    type: \"min_size\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.size < this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/minValue/minValue.ts\nfunction minValue(requirement, message = \"Invalid value\") {\n  return {\n    type: \"min_value\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input < this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\nvar minRange = minValue;\n\n// src/validations/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message = \"Invalid multiple\") {\n  return {\n    type: \"multiple_of\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input % this.requirement !== 0 ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/notBytes/notBytes.ts\nfunction notBytes(requirement, message = \"Invalid byte length\") {\n  return {\n    type: \"not_bytes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return new TextEncoder().encode(input).length === this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/notLength/notLength.ts\nfunction notLength(requirement, message = \"Invalid length\") {\n  return {\n    type: \"not_length\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.length === this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/notSize/notSize.ts\nfunction notSize(requirement, message = \"Invalid size\") {\n  return {\n    type: \"not_size\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.size === this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/notValue/notValue.ts\nfunction notValue(requirement, message = \"Invalid value\") {\n  return {\n    type: \"not_value\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input === this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/octal/octal.ts\nfunction octal(message = \"Invalid octal\") {\n  return {\n    type: \"octal\",\n    async: false,\n    message,\n    requirement: OCTAL_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/regex/regex.ts\nfunction regex(requirement, message = \"Invalid regex\") {\n  return {\n    type: \"regex\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/safeInteger/safeInteger.ts\nfunction safeInteger(message = \"Invalid safe integer\") {\n  return {\n    type: \"safe_integer\",\n    async: false,\n    message,\n    requirement: Number.isSafeInteger,\n    _parse(input) {\n      return !this.requirement(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/size/size.ts\nfunction size(requirement, message = \"Invalid size\") {\n  return {\n    type: \"size\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.size !== this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/startsWith/startsWith.ts\nfunction startsWith(requirement, message = \"Invalid start\") {\n  return {\n    type: \"stars_with\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !input.startsWith(this.requirement) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/ulid/ulid.ts\nfunction ulid(message = \"Invalid ULID\") {\n  return {\n    type: \"ulid\",\n    async: false,\n    message,\n    requirement: ULID_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/url/url.ts\nfunction url(message = \"Invalid URL\") {\n  return {\n    type: \"url\",\n    async: false,\n    message,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    _parse(input) {\n      return !this.requirement(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/uuid/uuid.ts\nfunction uuid(message = \"Invalid UUID\") {\n  return {\n    type: \"uuid\",\n    async: false,\n    message,\n    requirement: UUID_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n// src/validations/value/value.ts\nfunction value(requirement, message = \"Invalid value\") {\n  return {\n    type: \"value\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input !== this.requirement ? actionIssue(this.type, this.message, input, this.requirement) : actionOutput(input);\n    }\n  };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdmFsaWJvdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0EseUNBQXlDLEtBQUs7QUFDOUM7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsOEJBQThCO0FBQ2pHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsOEJBQThCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0RBQWtEO0FBQ2xFLGdCQUFnQjtBQUNoQiwyQkFBMkIsK0JBQStCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtEQUFrRDtBQUNwRSxrQkFBa0I7QUFDbEIsNkJBQTZCLCtCQUErQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0JBQW9CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtCQUErQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtCQUErQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLDRCQUE0QjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLDRCQUE0QjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDZCQUE2QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDZCQUE2QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHVCQUF1QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx1QkFBdUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixFQUFFLGNBQWMsRUFBRSxXQUFXLEVBQUU7QUFDdkQ7QUFDQTtBQUNBLDJFQUEyRSxHQUFHO0FBQzlFLHdCQUF3QixzQkFBc0IsR0FBRyxnQkFBZ0I7QUFDakU7QUFDQSxrQ0FBa0MsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRTtBQUNyRSxzQkFBc0IsRUFBRSxhQUFhLEVBQUUsRUFBRSxFQUFFO0FBQzNDO0FBQ0E7QUFDQSxpRkFBaUYsRUFBRTtBQUNuRjtBQUNBLGlDQUFpQyxJQUFJLEdBQUcsRUFBRSxRQUFRLElBQUksWUFBWSxJQUFJLEdBQUcsSUFBSSxhQUFhLElBQUksR0FBRyxJQUFJLFNBQVMsSUFBSSxZQUFZLElBQUksR0FBRyxJQUFJLFlBQVksSUFBSSxFQUFFLElBQUksWUFBWSxJQUFJLEdBQUcsSUFBSSxZQUFZLElBQUksRUFBRSxJQUFJLFlBQVksSUFBSSxHQUFHLElBQUksWUFBWSxJQUFJLEVBQUUsSUFBSSxZQUFZLElBQUksR0FBRyxJQUFJLFlBQVksSUFBSSxFQUFFLElBQUksU0FBUyxJQUFJLGFBQWEsSUFBSSxFQUFFLElBQUksaUJBQWlCLElBQUksRUFBRSxJQUFJLHFCQUFxQixJQUFJLEVBQUUsSUFBSSxpQkFBaUIsRUFBRSxNQUFNLElBQUksMENBQTBDLEVBQUUsMENBQTBDLElBQUksR0FBRyxJQUFJLHNDQUFzQyxFQUFFO0FBQzFpQiwwQkFBMEIsRUFBRTtBQUM1QiwrQkFBK0IsRUFBRTtBQUNqQztBQUNBLDZEQUE2RCxFQUFFO0FBQy9ELCtCQUErQixFQUFFLDBFQUEwRSxFQUFFLEtBQUssRUFBRTtBQUNwSCwwQkFBMEIsRUFBRTtBQUM1QiwrQkFBK0IsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFO0FBQy9HLCtCQUErQixFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUU7QUFDOUk7QUFDQSxxQ0FBcUMsR0FBRztBQUN4QywyQkFBMkIsRUFBRSxZQUFZLEVBQUUsRUFBRSxFQUFFLFNBQVMsR0FBRzs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZjtBQUNBLHlCQUF5QixHQUFHO0FBQzVCO0FBQ0EsZ0JBQWdCLEVBQUUsSUFBSSxNQUFNO0FBQzVCO0FBQ0Esc0JBQXNCLEVBQUUsSUFBSSxHQUFHO0FBQy9CO0FBQ0EsYUFBYSxFQUFFLDJCQUEyQixFQUFFLGtCQUFrQixHQUFHO0FBQ2pFO0FBQ0EsYUFBYSxHQUFHLE1BQU0sTUFBTTtBQUM1QjtBQUNBLFFBQVEsR0FBRyxNQUFNLElBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBK05FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGFpbHdpbmR1aS10cmFuc21pdC8uL25vZGVfbW9kdWxlcy92YWxpYm90L2Rpc3QvaW5kZXguanM/MTU2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZXJyb3IvZmxhdHRlbi9mbGF0dGVuLnRzXG5mdW5jdGlvbiBmbGF0dGVuKGFyZzEpIHtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5KGFyZzEpID8gYXJnMSA6IGFyZzEuaXNzdWVzKS5yZWR1Y2UoXG4gICAgKGZsYXRFcnJvcnMsIGlzc3VlKSA9PiB7XG4gICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICBpZiAoaXNzdWUucGF0aC5ldmVyeShcbiAgICAgICAgICAoeyBrZXkgfSkgPT4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Yga2V5ID09PSBcIm51bWJlclwiXG4gICAgICAgICkpIHtcbiAgICAgICAgICBjb25zdCBwYXRoID0gaXNzdWUucGF0aC5tYXAoKHsga2V5IH0pID0+IGtleSkuam9pbihcIi5cIik7XG4gICAgICAgICAgaWYgKGZsYXRFcnJvcnMubmVzdGVkW3BhdGhdKSB7XG4gICAgICAgICAgICBmbGF0RXJyb3JzLm5lc3RlZFtwYXRoXS5wdXNoKGlzc3VlLm1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbGF0RXJyb3JzLm5lc3RlZFtwYXRoXSA9IFtpc3N1ZS5tZXNzYWdlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmbGF0RXJyb3JzLnJvb3QpIHtcbiAgICAgICAgICBmbGF0RXJyb3JzLnJvb3QucHVzaChpc3N1ZS5tZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbGF0RXJyb3JzLnJvb3QgPSBbaXNzdWUubWVzc2FnZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmbGF0RXJyb3JzO1xuICAgIH0sXG4gICAgeyBuZXN0ZWQ6IHt9IH1cbiAgKTtcbn1cblxuLy8gc3JjL2Vycm9yL1ZhbGlFcnJvci9WYWxpRXJyb3IudHNcbnZhciBWYWxpRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgaXNzdWVzO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFZhbGlib3QgZXJyb3Igd2l0aCB1c2VmdWwgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBpc3N1ZXMgVGhlIGVycm9yIGlzc3Vlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGlzc3Vlcykge1xuICAgIHN1cGVyKGlzc3Vlc1swXS5tZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlZhbGlFcnJvclwiO1xuICAgIHRoaXMuaXNzdWVzID0gaXNzdWVzO1xuICB9XG59O1xuXG4vLyBzcmMvbWV0aG9kcy9icmFuZC9icmFuZC50c1xudmFyIEJyYW5kU3ltYm9sID0gU3ltYm9sKFwiYnJhbmRcIik7XG5mdW5jdGlvbiBicmFuZChzY2hlbWEsIG5hbWUpIHtcbiAgcmV0dXJuIHNjaGVtYTtcbn1cblxuLy8gc3JjL21ldGhvZHMvY29lcmNlL2NvZXJjZS50c1xuZnVuY3Rpb24gY29lcmNlKHNjaGVtYSwgYWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgcmV0dXJuIHNjaGVtYS5fcGFyc2UoYWN0aW9uKGlucHV0KSwgaW5mbyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9jb2VyY2UvY29lcmNlQXN5bmMudHNcbmZ1bmN0aW9uIGNvZXJjZUFzeW5jKHNjaGVtYSwgYWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgcmV0dXJuIHNjaGVtYS5fcGFyc2UoYXdhaXQgYWN0aW9uKGlucHV0KSwgaW5mbyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMvZXJyb3JNZXNzYWdlL2Vycm9yTWVzc2FnZS50c1xuZnVuY3Rpb24gZXJyb3JNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIgPyBtZXNzYWdlKCkgOiBtZXNzYWdlO1xufVxuXG4vLyBzcmMvdXRpbHMvYWN0aW9uSXNzdWUvYWN0aW9uSXNzdWUudHNcbmZ1bmN0aW9uIGFjdGlvbklzc3VlKHZhbGlkYXRpb24sIG1lc3NhZ2UsIGlucHV0LCByZXF1aXJlbWVudCwgcGF0aCkge1xuICByZXR1cm4ge1xuICAgIGlzc3VlczogW1xuICAgICAge1xuICAgICAgICB2YWxpZGF0aW9uLFxuICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UobWVzc2FnZSksXG4gICAgICAgIGlucHV0LFxuICAgICAgICByZXF1aXJlbWVudCxcbiAgICAgICAgcGF0aFxuICAgICAgfVxuICAgIF1cbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2FjdGlvbk91dHB1dC9hY3Rpb25PdXRwdXQudHNcbmZ1bmN0aW9uIGFjdGlvbk91dHB1dChvdXRwdXQpIHtcbiAgcmV0dXJuIHsgb3V0cHV0IH07XG59XG5cbi8vIHNyYy91dGlscy9kZWZhdWx0QXJncy9kZWZhdWx0QXJncy50c1xuZnVuY3Rpb24gZGVmYXVsdEFyZ3MoYXJnMSwgYXJnMikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcxKSA/IFt2b2lkIDAsIGFyZzFdIDogW2FyZzEsIGFyZzJdO1xufVxuXG4vLyBzcmMvdXRpbHMvcGFyc2VSZXN1bHQvcGFyc2VSZXN1bHQudHNcbmZ1bmN0aW9uIHBhcnNlUmVzdWx0KHR5cGVkLCBvdXRwdXQsIGlzc3Vlcykge1xuICByZXR1cm4geyB0eXBlZCwgb3V0cHV0LCBpc3N1ZXMgfTtcbn1cblxuLy8gc3JjL3V0aWxzL3Jlc3RBbmREZWZhdWx0QXJncy9yZXN0QW5kRGVmYXVsdEFyZ3MudHNcbmZ1bmN0aW9uIHJlc3RBbmREZWZhdWx0QXJncyhhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICghYXJnMSB8fCB0eXBlb2YgYXJnMSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgIGNvbnN0IFtlcnJvcjIsIHBpcGUyXSA9IGRlZmF1bHRBcmdzKGFyZzIsIGFyZzMpO1xuICAgIHJldHVybiBbYXJnMSwgZXJyb3IyLCBwaXBlMl07XG4gIH1cbiAgY29uc3QgW2Vycm9yLCBwaXBlXSA9IGRlZmF1bHRBcmdzKFxuICAgIGFyZzEsXG4gICAgYXJnMlxuICApO1xuICByZXR1cm4gW3ZvaWQgMCwgZXJyb3IsIHBpcGVdO1xufVxuXG4vLyBzcmMvdXRpbHMvaXNMdWhuQWxnby9pc0x1aG5BbGdvLnRzXG52YXIgTk9OX0RJR0lUX1JFR0VYID0gL1xcRC9ndTtcbmZ1bmN0aW9uIGlzTHVobkFsZ28oaW5wdXQpIHtcbiAgY29uc3QgbnVtYmVyMiA9IGlucHV0LnJlcGxhY2UoTk9OX0RJR0lUX1JFR0VYLCBcIlwiKTtcbiAgbGV0IGxlbmd0aDIgPSBudW1iZXIyLmxlbmd0aDtcbiAgbGV0IGJpdCA9IDE7XG4gIGxldCBzdW0gPSAwO1xuICB3aGlsZSAobGVuZ3RoMikge1xuICAgIGNvbnN0IHZhbHVlMiA9ICtudW1iZXIyWy0tbGVuZ3RoMl07XG4gICAgYml0IF49IDE7XG4gICAgc3VtICs9IGJpdCA/IFswLCAyLCA0LCA2LCA4LCAxLCAzLCA1LCA3LCA5XVt2YWx1ZTJdIDogdmFsdWUyO1xuICB9XG4gIHJldHVybiBzdW0gJSAxMCA9PT0gMDtcbn1cblxuLy8gc3JjL3V0aWxzL3BpcGVSZXN1bHQvdXRpbHMvcGlwZUlzc3VlL3BpcGVJc3N1ZS50c1xuZnVuY3Rpb24gcGlwZUlzc3VlKGluZm8sIGlzc3VlKSB7XG4gIHJldHVybiB7XG4gICAgcmVhc29uOiBpbmZvPy5yZWFzb24sXG4gICAgdmFsaWRhdGlvbjogaXNzdWUudmFsaWRhdGlvbixcbiAgICBvcmlnaW46IGluZm8/Lm9yaWdpbiB8fCBcInZhbHVlXCIsXG4gICAgbWVzc2FnZTogaXNzdWUubWVzc2FnZSxcbiAgICBpbnB1dDogaXNzdWUuaW5wdXQsXG4gICAgcmVxdWlyZW1lbnQ6IGlzc3VlPy5yZXF1aXJlbWVudCxcbiAgICBwYXRoOiBpc3N1ZS5wYXRoLFxuICAgIGFib3J0RWFybHk6IGluZm8/LmFib3J0RWFybHksXG4gICAgYWJvcnRQaXBlRWFybHk6IGluZm8/LmFib3J0UGlwZUVhcmx5LFxuICAgIHNraXBQaXBlOiBpbmZvPy5za2lwUGlwZVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMvcGlwZVJlc3VsdC91dGlscy9waXBlSW5mby9waXBlSW5mby50c1xuZnVuY3Rpb24gcGlwZUluZm8oaW5mbywgcmVhc29uKSB7XG4gIHJldHVybiB7XG4gICAgcmVhc29uLFxuICAgIG9yaWdpbjogaW5mbz8ub3JpZ2luLFxuICAgIGFib3J0RWFybHk6IGluZm8/LmFib3J0RWFybHksXG4gICAgYWJvcnRQaXBlRWFybHk6IGluZm8/LmFib3J0UGlwZUVhcmx5LFxuICAgIHNraXBQaXBlOiBpbmZvPy5za2lwUGlwZVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMvcGlwZVJlc3VsdC9waXBlUmVzdWx0LnRzXG5mdW5jdGlvbiBwaXBlUmVzdWx0KGlucHV0LCBwaXBlLCBwYXJzZUluZm8sIHJlYXNvbiwgaXNzdWVzKSB7XG4gIGxldCBpbmZvO1xuICBsZXQgb3V0cHV0ID0gaW5wdXQ7XG4gIGlmIChwaXBlPy5sZW5ndGggJiYgIXBhcnNlSW5mbz8uc2tpcFBpcGUpIHtcbiAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBwaXBlKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhY3Rpb24uX3BhcnNlKG91dHB1dCk7XG4gICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICBpbmZvID0gaW5mbyB8fCBwaXBlSW5mbyhwYXJzZUluZm8sIHJlYXNvbik7XG4gICAgICAgIGZvciAoY29uc3QgaXNzdWVJbmZvIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICBjb25zdCBpc3N1ZSA9IHBpcGVJc3N1ZShpbmZvLCBpc3N1ZUluZm8pO1xuICAgICAgICAgIGlzc3VlcyA/IGlzc3Vlcy5wdXNoKGlzc3VlKSA6IGlzc3VlcyA9IFtpc3N1ZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZm8uYWJvcnRFYXJseSB8fCBpbmZvLmFib3J0UGlwZUVhcmx5KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dCA9IHJlc3VsdC5vdXRwdXQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJzZVJlc3VsdCh0cnVlLCBvdXRwdXQsIGlzc3Vlcyk7XG59XG5cbi8vIHNyYy91dGlscy9waXBlUmVzdWx0L3BpcGVSZXN1bHRBc3luYy50c1xuYXN5bmMgZnVuY3Rpb24gcGlwZVJlc3VsdEFzeW5jKGlucHV0LCBwaXBlLCBwYXJzZUluZm8sIHJlYXNvbiwgaXNzdWVzKSB7XG4gIGxldCBpbmZvO1xuICBsZXQgb3V0cHV0ID0gaW5wdXQ7XG4gIGlmIChwaXBlPy5sZW5ndGggJiYgIXBhcnNlSW5mbz8uc2tpcFBpcGUpIHtcbiAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBwaXBlKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhY3Rpb24uX3BhcnNlKG91dHB1dCk7XG4gICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICBpbmZvID0gaW5mbyB8fCBwaXBlSW5mbyhwYXJzZUluZm8sIHJlYXNvbik7XG4gICAgICAgIGZvciAoY29uc3QgaXNzdWVJbmZvIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICBjb25zdCBpc3N1ZSA9IHBpcGVJc3N1ZShpbmZvLCBpc3N1ZUluZm8pO1xuICAgICAgICAgIGlzc3VlcyA/IGlzc3Vlcy5wdXNoKGlzc3VlKSA6IGlzc3VlcyA9IFtpc3N1ZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZm8uYWJvcnRFYXJseSB8fCBpbmZvLmFib3J0UGlwZUVhcmx5KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dCA9IHJlc3VsdC5vdXRwdXQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJzZVJlc3VsdCh0cnVlLCBvdXRwdXQsIGlzc3Vlcyk7XG59XG5cbi8vIHNyYy91dGlscy9zY2hlbWFJc3N1ZS9zY2hlbWFJc3N1ZS50c1xuZnVuY3Rpb24gc2NoZW1hSXNzdWUoaW5mbywgcmVhc29uLCB2YWxpZGF0aW9uLCBtZXNzYWdlLCBpbnB1dCwgcGF0aCwgaXNzdWVzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZWQ6IGZhbHNlLFxuICAgIG91dHB1dDogaW5wdXQsXG4gICAgaXNzdWVzOiBbXG4gICAgICB7XG4gICAgICAgIHJlYXNvbixcbiAgICAgICAgdmFsaWRhdGlvbixcbiAgICAgICAgb3JpZ2luOiBpbmZvPy5vcmlnaW4gfHwgXCJ2YWx1ZVwiLFxuICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UobWVzc2FnZSksXG4gICAgICAgIGlucHV0LFxuICAgICAgICBwYXRoLFxuICAgICAgICBpc3N1ZXMsXG4gICAgICAgIGFib3J0RWFybHk6IGluZm8/LmFib3J0RWFybHksXG4gICAgICAgIGFib3J0UGlwZUVhcmx5OiBpbmZvPy5hYm9ydFBpcGVFYXJseSxcbiAgICAgICAgc2tpcFBpcGU6IGluZm8/LnNraXBQaXBlXG4gICAgICB9XG4gICAgXVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9nZXRGYWxsYmFjay9nZXRGYWxsYmFjay50c1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2soc2NoZW1hLCBpbmZvKSB7XG4gIHJldHVybiB0eXBlb2Ygc2NoZW1hLmZhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIgPyBzY2hlbWEuZmFsbGJhY2soaW5mbykgOiBzY2hlbWEuZmFsbGJhY2s7XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldEZhbGxiYWNrL2dldEZhbGxiYWNrQXN5bmMudHNcbmFzeW5jIGZ1bmN0aW9uIGdldEZhbGxiYWNrQXN5bmMoc2NoZW1hLCBpbmZvKSB7XG4gIHJldHVybiB0eXBlb2Ygc2NoZW1hLmZhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIgPyBhd2FpdCBzY2hlbWEuZmFsbGJhY2soaW5mbykgOiBzY2hlbWEuZmFsbGJhY2s7XG59XG5cbi8vIHNyYy9tZXRob2RzL2ZhbGxiYWNrL2ZhbGxiYWNrLnRzXG5mdW5jdGlvbiBmYWxsYmFjayhzY2hlbWEsIGZhbGxiYWNrMikge1xuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICBmYWxsYmFjazogZmFsbGJhY2syLFxuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgICByZXR1cm4gcmVzdWx0Lmlzc3VlcyA/IHBhcnNlUmVzdWx0KHRydWUsIGdldEZhbGxiYWNrKHRoaXMsIHsgaW5wdXQsIGlzc3VlczogcmVzdWx0Lmlzc3VlcyB9KSkgOiByZXN1bHQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9mYWxsYmFjay9mYWxsYmFja0FzeW5jLnRzXG5mdW5jdGlvbiBmYWxsYmFja0FzeW5jKHNjaGVtYSwgZmFsbGJhY2syKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIGZhbGxiYWNrOiBmYWxsYmFjazIsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzY2hlbWEuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgICAgIHJldHVybiByZXN1bHQuaXNzdWVzID8gcGFyc2VSZXN1bHQoXG4gICAgICAgIHRydWUsXG4gICAgICAgIGF3YWl0IGdldEZhbGxiYWNrQXN5bmModGhpcywgeyBpbnB1dCwgaXNzdWVzOiByZXN1bHQuaXNzdWVzIH0pXG4gICAgICApIDogcmVzdWx0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZm9yd2FyZC9mb3J3YXJkLnRzXG5mdW5jdGlvbiBmb3J3YXJkKHZhbGlkYXRpb24sIHBhdGhMaXN0KSB7XG4gIHJldHVybiB7XG4gICAgLi4udmFsaWRhdGlvbixcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRpb24uX3BhcnNlKGlucHV0KTtcbiAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgcmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgIGxldCBwYXRoSW5wdXQgPSBpbnB1dDtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBwYXRoTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgcGF0aFZhbHVlID0gcGF0aElucHV0W2tleV07XG4gICAgICAgICAgICBpc3N1ZS5pbnB1dCA9IHBhdGhWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcInVua25vd25cIixcbiAgICAgICAgICAgICAgaW5wdXQ6IHBhdGhJbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogcGF0aFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaXNzdWUucGF0aCA/IGlzc3VlLnBhdGgucHVzaChwYXRoSXRlbSkgOiBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgIGlmICghcGF0aFZhbHVlKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aElucHV0ID0gcGF0aFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldERlZmF1bHQvZ2V0RGVmYXVsdC50c1xuZnVuY3Rpb24gZ2V0RGVmYXVsdChzY2hlbWEpIHtcbiAgcmV0dXJuIHR5cGVvZiBzY2hlbWEuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiID8gc2NoZW1hLmRlZmF1bHQoKSA6IHNjaGVtYS5kZWZhdWx0O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9nZXREZWZhdWx0L2dldERlZmF1bHRBc3luYy50c1xuYXN5bmMgZnVuY3Rpb24gZ2V0RGVmYXVsdEFzeW5jKHNjaGVtYSkge1xuICByZXR1cm4gdHlwZW9mIHNjaGVtYS5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgPyBhd2FpdCBzY2hlbWEuZGVmYXVsdCgpIDogc2NoZW1hLmRlZmF1bHQ7XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldERlZmF1bHRzL2dldERlZmF1bHRzLnRzXG5mdW5jdGlvbiBnZXREZWZhdWx0cyhzY2hlbWEpIHtcbiAgbGV0IGRlZmF1bHRzO1xuICBpZiAoc2NoZW1hLmRlZmF1bHQpIHtcbiAgICBkZWZhdWx0cyA9IGdldERlZmF1bHQoc2NoZW1hKTtcbiAgfSBlbHNlIGlmIChcInR5cGVcIiBpbiBzY2hlbWEpIHtcbiAgICBpZiAoc2NoZW1hLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGRlZmF1bHRzID0ge307XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuZW50cmllcykge1xuICAgICAgICBkZWZhdWx0c1trZXldID0gZ2V0RGVmYXVsdHMoc2NoZW1hLmVudHJpZXNba2V5XSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzY2hlbWEudHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICBkZWZhdWx0cyA9IFtdO1xuICAgICAgZm9yIChsZXQga2V5ID0gMDsga2V5IDwgc2NoZW1hLml0ZW1zLmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgZGVmYXVsdHMucHVzaChnZXREZWZhdWx0cyhzY2hlbWEuaXRlbXNba2V5XSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGVmYXVsdHM7XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldERlZmF1bHRzL2dldERlZmF1bHRzQXN5bmMudHNcbmFzeW5jIGZ1bmN0aW9uIGdldERlZmF1bHRzQXN5bmMoc2NoZW1hKSB7XG4gIGxldCBkZWZhdWx0cztcbiAgaWYgKHNjaGVtYS5kZWZhdWx0KSB7XG4gICAgZGVmYXVsdHMgPSBhd2FpdCBnZXREZWZhdWx0QXN5bmMoc2NoZW1hKTtcbiAgfSBlbHNlIGlmIChcInR5cGVcIiBpbiBzY2hlbWEpIHtcbiAgICBpZiAoc2NoZW1hLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGRlZmF1bHRzID0ge307XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuZW50cmllcykge1xuICAgICAgICBkZWZhdWx0c1trZXldID0gYXdhaXQgZ2V0RGVmYXVsdHNBc3luYyhzY2hlbWEuZW50cmllc1trZXldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjaGVtYS50eXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgIGRlZmF1bHRzID0gW107XG4gICAgICBmb3IgKGxldCBrZXkgPSAwOyBrZXkgPCBzY2hlbWEuaXRlbXMubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICBkZWZhdWx0cy5wdXNoKGF3YWl0IGdldERlZmF1bHRzQXN5bmMoc2NoZW1hLml0ZW1zW2tleV0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRzO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9nZXRGYWxsYmFja3MvZ2V0RmFsbGJhY2tzLnRzXG5mdW5jdGlvbiBnZXRGYWxsYmFja3Moc2NoZW1hKSB7XG4gIGxldCBmYWxsYmFja3M7XG4gIGlmIChzY2hlbWEuZmFsbGJhY2spIHtcbiAgICBmYWxsYmFja3MgPSBnZXRGYWxsYmFjayhzY2hlbWEpO1xuICB9IGVsc2UgaWYgKFwidHlwZVwiIGluIHNjaGVtYSkge1xuICAgIGlmIChzY2hlbWEudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZmFsbGJhY2tzID0ge307XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuZW50cmllcykge1xuICAgICAgICBmYWxsYmFja3Nba2V5XSA9IGdldEZhbGxiYWNrcyhzY2hlbWEuZW50cmllc1trZXldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjaGVtYS50eXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgIGZhbGxiYWNrcyA9IFtdO1xuICAgICAgZm9yIChsZXQga2V5ID0gMDsga2V5IDwgc2NoZW1hLml0ZW1zLmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgZmFsbGJhY2tzLnB1c2goZ2V0RmFsbGJhY2tzKHNjaGVtYS5pdGVtc1trZXldKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxsYmFja3M7XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldEZhbGxiYWNrcy9nZXRGYWxsYmFja3NBc3luYy50c1xuYXN5bmMgZnVuY3Rpb24gZ2V0RmFsbGJhY2tzQXN5bmMoc2NoZW1hKSB7XG4gIGxldCBmYWxsYmFja3M7XG4gIGlmIChzY2hlbWEuZmFsbGJhY2spIHtcbiAgICBmYWxsYmFja3MgPSBhd2FpdCBnZXRGYWxsYmFja0FzeW5jKHNjaGVtYSk7XG4gIH0gZWxzZSBpZiAoXCJ0eXBlXCIgaW4gc2NoZW1hKSB7XG4gICAgaWYgKHNjaGVtYS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmYWxsYmFja3MgPSB7fTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBPYmplY3QuZW50cmllcyhzY2hlbWEuZW50cmllcykubWFwKGFzeW5jIChba2V5LCBzY2hlbWEyXSkgPT4ge1xuICAgICAgICAgIGZhbGxiYWNrc1trZXldID0gYXdhaXQgZ2V0RmFsbGJhY2tzQXN5bmMoc2NoZW1hMik7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoc2NoZW1hLnR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgZmFsbGJhY2tzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHNjaGVtYS5pdGVtcy5tYXAoKHNjaGVtYTIpID0+IGdldEZhbGxiYWNrc0FzeW5jKHNjaGVtYTIpKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbGxiYWNrcztcbn1cblxuLy8gc3JjL21ldGhvZHMvaXMvaXMudHNcbmZ1bmN0aW9uIGlzKHNjaGVtYSwgaW5wdXQsIGluZm8pIHtcbiAgcmV0dXJuICFzY2hlbWEuX3BhcnNlKGlucHV0LCB7XG4gICAgYWJvcnRFYXJseTogdHJ1ZSxcbiAgICBza2lwUGlwZTogaW5mbz8uc2tpcFBpcGVcbiAgfSkuaXNzdWVzO1xufVxuXG4vLyBzcmMvc2NoZW1hcy9hbnkvYW55LnRzXG5mdW5jdGlvbiBhbnkocGlwZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYW55XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHBpcGUsXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICByZXR1cm4gcGlwZVJlc3VsdChpbnB1dCwgdGhpcy5waXBlLCBpbmZvLCBcImFueVwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2FueS9hbnlBc3luYy50c1xuZnVuY3Rpb24gYW55QXN5bmMocGlwZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYW55XCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgcGlwZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmMoaW5wdXQsIHRoaXMucGlwZSwgaW5mbywgXCJhbnlcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9hcnJheS9hcnJheS50c1xuZnVuY3Rpb24gYXJyYXkoaXRlbSwgYXJnMiwgYXJnMykge1xuICBjb25zdCBbbWVzc2FnZSA9IFwiSW52YWxpZCB0eXBlXCIsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMiwgYXJnMyk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBpdGVtLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcImFycmF5XCIsIHRoaXMubWVzc2FnZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgbGV0IHR5cGVkID0gdHJ1ZTtcbiAgICAgIGxldCBpc3N1ZXM7XG4gICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgIGZvciAobGV0IGtleSA9IDA7IGtleSA8IGlucHV0Lmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5pdGVtLl9wYXJzZSh2YWx1ZTIsIGluZm8pO1xuICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgfTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNzdWVzKSB7XG4gICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5mbz8uYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdC50eXBlZCkge1xuICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnB1c2gocmVzdWx0Lm91dHB1dCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZWQpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHQoXG4gICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgIHRoaXMucGlwZSxcbiAgICAgICAgICBpbmZvLFxuICAgICAgICAgIFwiYXJyYXlcIixcbiAgICAgICAgICBpc3N1ZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZVJlc3VsdChmYWxzZSwgb3V0cHV0LCBpc3N1ZXMpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvYXJyYXkvYXJyYXlBc3luYy50c1xuZnVuY3Rpb24gYXJyYXlBc3luYyhpdGVtLCBhcmcyLCBhcmczKSB7XG4gIGNvbnN0IFttZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIiwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcyLCBhcmczKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgaXRlbSxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJhcnJheVwiLCB0aGlzLm1lc3NhZ2UsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIGxldCB0eXBlZCA9IHRydWU7XG4gICAgICBsZXQgaXNzdWVzO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgaW5wdXQubWFwKGFzeW5jICh2YWx1ZTIsIGtleSkgPT4ge1xuICAgICAgICAgIGlmICghKGluZm8/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5pdGVtLl9wYXJzZSh2YWx1ZTIsIGluZm8pO1xuICAgICAgICAgICAgaWYgKCEoaW5mbz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgcmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlcyA9IHJlc3VsdC5pc3N1ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmZvPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dHB1dFtrZXldID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgaWYgKHR5cGVkKSB7XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmMoXG4gICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgIHRoaXMucGlwZSxcbiAgICAgICAgICBpbmZvLFxuICAgICAgICAgIFwiYXJyYXlcIixcbiAgICAgICAgICBpc3N1ZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZVJlc3VsdChmYWxzZSwgb3V0cHV0LCBpc3N1ZXMpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvYmlnaW50L2JpZ2ludC50c1xuZnVuY3Rpb24gYmlnaW50KGFyZzEsIGFyZzIpIHtcbiAgY29uc3QgW21lc3NhZ2UgPSBcIkludmFsaWQgdHlwZVwiLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzEsIGFyZzIpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcImJpZ2ludFwiLCB0aGlzLm1lc3NhZ2UsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwaXBlUmVzdWx0KGlucHV0LCB0aGlzLnBpcGUsIGluZm8sIFwiYmlnaW50XCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvYmlnaW50L2JpZ2ludEFzeW5jLnRzXG5mdW5jdGlvbiBiaWdpbnRBc3luYyhhcmcxLCBhcmcyKSB7XG4gIGNvbnN0IFttZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIiwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcxLCBhcmcyKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcImJpZ2ludFwiLCB0aGlzLm1lc3NhZ2UsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmMoaW5wdXQsIHRoaXMucGlwZSwgaW5mbywgXCJiaWdpbnRcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ibG9iL2Jsb2IudHNcbmZ1bmN0aW9uIGJsb2IoYXJnMSwgYXJnMikge1xuICBjb25zdCBbbWVzc2FnZSA9IFwiSW52YWxpZCB0eXBlXCIsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMSwgYXJnMik7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJibG9iXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcImJsb2JcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGlwZVJlc3VsdChpbnB1dCwgdGhpcy5waXBlLCBpbmZvLCBcImJsb2JcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ibG9iL2Jsb2JBc3luYy50c1xuZnVuY3Rpb24gYmxvYkFzeW5jKGFyZzEsIGFyZzIpIHtcbiAgY29uc3QgW21lc3NhZ2UgPSBcIkludmFsaWQgdHlwZVwiLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzEsIGFyZzIpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYmxvYlwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcImJsb2JcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGlwZVJlc3VsdEFzeW5jKGlucHV0LCB0aGlzLnBpcGUsIGluZm8sIFwiYmxvYlwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2Jvb2xlYW4vYm9vbGVhbi50c1xuZnVuY3Rpb24gYm9vbGVhbihhcmcxLCBhcmcyKSB7XG4gIGNvbnN0IFttZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIiwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcxLCBhcmcyKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcImJvb2xlYW5cIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGlwZVJlc3VsdChpbnB1dCwgdGhpcy5waXBlLCBpbmZvLCBcImJvb2xlYW5cIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ib29sZWFuL2Jvb2xlYW5Bc3luYy50c1xuZnVuY3Rpb24gYm9vbGVhbkFzeW5jKGFyZzEsIGFyZzIpIHtcbiAgY29uc3QgW21lc3NhZ2UgPSBcIkludmFsaWQgdHlwZVwiLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzEsIGFyZzIpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJib29sZWFuXCIsIHRoaXMubWVzc2FnZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyhpbnB1dCwgdGhpcy5waXBlLCBpbmZvLCBcImJvb2xlYW5cIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9kYXRlL2RhdGUudHNcbmZ1bmN0aW9uIGRhdGUoYXJnMSwgYXJnMikge1xuICBjb25zdCBbbWVzc2FnZSA9IFwiSW52YWxpZCB0eXBlXCIsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMSwgYXJnMik7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJkYXRlXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkgfHwgaXNOYU4oaW5wdXQuZ2V0VGltZSgpKSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUoaW5mbywgXCJ0eXBlXCIsIFwiZGF0ZVwiLCB0aGlzLm1lc3NhZ2UsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwaXBlUmVzdWx0KGlucHV0LCB0aGlzLnBpcGUsIGluZm8sIFwiZGF0ZVwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2RhdGUvZGF0ZUFzeW5jLnRzXG5mdW5jdGlvbiBkYXRlQXN5bmMoYXJnMSwgYXJnMikge1xuICBjb25zdCBbbWVzc2FnZSA9IFwiSW52YWxpZCB0eXBlXCIsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMSwgYXJnMik7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJkYXRlXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSB8fCBpc05hTihpbnB1dC5nZXRUaW1lKCkpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJkYXRlXCIsIHRoaXMubWVzc2FnZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyhpbnB1dCwgdGhpcy5waXBlLCBpbmZvLCBcImRhdGVcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9lbnVtL2VudW0udHNcbmZ1bmN0aW9uIGVudW1fKGVudW1fMiwgbWVzc2FnZSA9IFwiSW52YWxpZCB0eXBlXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZW51bTogZW51bV8yLFxuICAgIG1lc3NhZ2UsXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoIU9iamVjdC52YWx1ZXModGhpcy5lbnVtKS5pbmNsdWRlcyhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcImVudW1cIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cbnZhciBuYXRpdmVFbnVtID0gZW51bV87XG5cbi8vIHNyYy9zY2hlbWFzL2VudW0vZW51bUFzeW5jLnRzXG5mdW5jdGlvbiBlbnVtQXN5bmMoZW51bV8yLCBtZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGVudW06IGVudW1fMixcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKCFPYmplY3QudmFsdWVzKHRoaXMuZW51bSkuaW5jbHVkZXMoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJlbnVtXCIsIHRoaXMubWVzc2FnZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICB9XG4gIH07XG59XG52YXIgbmF0aXZlRW51bUFzeW5jID0gZW51bUFzeW5jO1xuXG4vLyBzcmMvc2NoZW1hcy9pbnN0YW5jZS9pbnN0YW5jZS50c1xuZnVuY3Rpb24gaW5zdGFuY2UoY2xhc3NfLCBhcmcyLCBhcmczKSB7XG4gIGNvbnN0IFttZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIiwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcyLCBhcmczKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImluc3RhbmNlXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGNsYXNzOiBjbGFzc18sXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiB0aGlzLmNsYXNzKSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUoaW5mbywgXCJ0eXBlXCIsIFwiaW5zdGFuY2VcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGlwZVJlc3VsdChpbnB1dCwgdGhpcy5waXBlLCBpbmZvLCBcImluc3RhbmNlXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvaW5zdGFuY2UvaW5zdGFuY2VBc3luYy50c1xuZnVuY3Rpb24gaW5zdGFuY2VBc3luYyhjbGFzc18sIGFyZzIsIGFyZzMpIHtcbiAgY29uc3QgW21lc3NhZ2UgPSBcIkludmFsaWQgdHlwZVwiLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzIsIGFyZzMpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaW5zdGFuY2VcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBjbGFzczogY2xhc3NfLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgdGhpcy5jbGFzcykpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcImluc3RhbmNlXCIsIHRoaXMubWVzc2FnZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyhpbnB1dCwgdGhpcy5waXBlLCBpbmZvLCBcImluc3RhbmNlXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvaW50ZXJzZWN0L3V0aWxzL21lcmdlT3V0cHV0cy9tZXJnZU91dHB1dHMudHNcbmZ1bmN0aW9uIG1lcmdlT3V0cHV0cyhvdXRwdXQxLCBvdXRwdXQyKSB7XG4gIGlmICh0eXBlb2Ygb3V0cHV0MSA9PT0gdHlwZW9mIG91dHB1dDIpIHtcbiAgICBpZiAob3V0cHV0MSA9PT0gb3V0cHV0MiB8fCBvdXRwdXQxIGluc3RhbmNlb2YgRGF0ZSAmJiBvdXRwdXQyIGluc3RhbmNlb2YgRGF0ZSAmJiArb3V0cHV0MSA9PT0gK291dHB1dDIpIHtcbiAgICAgIHJldHVybiB7IG91dHB1dDogb3V0cHV0MSB9O1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvdXRwdXQxKSAmJiBBcnJheS5pc0FycmF5KG91dHB1dDIpKSB7XG4gICAgICBpZiAob3V0cHV0MS5sZW5ndGggPT09IG91dHB1dDIubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGFycmF5MiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgb3V0cHV0MS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBtZXJnZU91dHB1dHMob3V0cHV0MVtpbmRleF0sIG91dHB1dDJbaW5kZXhdKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmludmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFycmF5Mi5wdXNoKHJlc3VsdC5vdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG91dHB1dDogYXJyYXkyIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBpbnZhbGlkOiB0cnVlIH07XG4gICAgfVxuICAgIGlmIChvdXRwdXQxICYmIG91dHB1dDIgJiYgb3V0cHV0MS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmIG91dHB1dDIuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgY29uc3Qgb2JqZWN0MiA9IHsgLi4ub3V0cHV0MSwgLi4ub3V0cHV0MiB9O1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3V0cHV0MSkge1xuICAgICAgICBpZiAoa2V5IGluIG91dHB1dDIpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBtZXJnZU91dHB1dHMob3V0cHV0MVtrZXldLCBvdXRwdXQyW2tleV0pO1xuICAgICAgICAgIGlmIChyZXN1bHQuaW52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqZWN0MltrZXldID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgb3V0cHV0OiBvYmplY3QyIH07XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGludmFsaWQ6IHRydWUgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvaW50ZXJzZWN0L2ludGVyc2VjdC50c1xuZnVuY3Rpb24gaW50ZXJzZWN0KG9wdGlvbnMsIGFyZzIsIGFyZzMpIHtcbiAgY29uc3QgW21lc3NhZ2UgPSBcIkludmFsaWQgdHlwZVwiLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzIsIGFyZzMpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaW50ZXJzZWN0XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgbGV0IHR5cGVkID0gdHJ1ZTtcbiAgICAgIGxldCBpc3N1ZXM7XG4gICAgICBsZXQgb3V0cHV0O1xuICAgICAgY29uc3Qgb3V0cHV0cyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2YgdGhpcy5vcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHNjaGVtYS5fcGFyc2UoaW5wdXQsIGluZm8pO1xuICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgIGlmIChpc3N1ZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgcmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpc3N1ZXMucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzc3VlcyA9IHJlc3VsdC5pc3N1ZXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmZvPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRzLnB1c2gocmVzdWx0Lm91dHB1dCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZWQpIHtcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0c1swXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAxOyBpbmRleCA8IG91dHB1dHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWVyZ2VPdXRwdXRzKG91dHB1dCwgb3V0cHV0c1tpbmRleF0pO1xuICAgICAgICAgIGlmIChyZXN1bHQuaW52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcImludGVyc2VjdFwiLCB0aGlzLm1lc3NhZ2UsIGlucHV0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0ID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZVJlc3VsdChvdXRwdXQsIHRoaXMucGlwZSwgaW5mbywgXCJpbnRlcnNlY3RcIiwgaXNzdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZVJlc3VsdChmYWxzZSwgb3V0cHV0LCBpc3N1ZXMpO1xuICAgIH1cbiAgfTtcbn1cbnZhciBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Q7XG5cbi8vIHNyYy9zY2hlbWFzL2xpdGVyYWwvbGl0ZXJhbC50c1xuZnVuY3Rpb24gbGl0ZXJhbChsaXRlcmFsMiwgbWVzc2FnZSA9IFwiSW52YWxpZCB0eXBlXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImxpdGVyYWxcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbGl0ZXJhbDogbGl0ZXJhbDIsXG4gICAgbWVzc2FnZSxcbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmIChpbnB1dCAhPT0gdGhpcy5saXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJsaXRlcmFsXCIsIHRoaXMubWVzc2FnZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2xpdGVyYWwvbGl0ZXJhbEFzeW5jLnRzXG5mdW5jdGlvbiBsaXRlcmFsQXN5bmMobGl0ZXJhbDIsIG1lc3NhZ2UgPSBcIkludmFsaWQgdHlwZVwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJsaXRlcmFsXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgbGl0ZXJhbDogbGl0ZXJhbDIsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmIChpbnB1dCAhPT0gdGhpcy5saXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJsaXRlcmFsXCIsIHRoaXMubWVzc2FnZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL21hcC9tYXAudHNcbmZ1bmN0aW9uIG1hcChrZXksIHZhbHVlMiwgYXJnMywgYXJnNCkge1xuICBjb25zdCBbbWVzc2FnZSA9IFwiSW52YWxpZCB0eXBlXCIsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMywgYXJnNCk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJtYXBcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAga2V5LFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBNYXApKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJtYXBcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICBsZXQgdHlwZWQgPSB0cnVlO1xuICAgICAgbGV0IGlzc3VlcztcbiAgICAgIGNvbnN0IG91dHB1dCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGNvbnN0IFtpbnB1dEtleSwgaW5wdXRWYWx1ZV0gb2YgaW5wdXQuZW50cmllcygpKSB7XG4gICAgICAgIGxldCBwYXRoSXRlbTtcbiAgICAgICAgY29uc3Qga2V5UmVzdWx0ID0gdGhpcy5rZXkuX3BhcnNlKGlucHV0S2V5LCB7XG4gICAgICAgICAgb3JpZ2luOiBcImtleVwiLFxuICAgICAgICAgIGFib3J0RWFybHk6IGluZm8/LmFib3J0RWFybHksXG4gICAgICAgICAgYWJvcnRQaXBlRWFybHk6IGluZm8/LmFib3J0UGlwZUVhcmx5LFxuICAgICAgICAgIHNraXBQaXBlOiBpbmZvPy5za2lwUGlwZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGtleVJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwibWFwXCIsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGtleTogaW5wdXRLZXksXG4gICAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBrZXlSZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgaXNzdWVzID0ga2V5UmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZm8/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWVSZXN1bHQgPSB0aGlzLnZhbHVlLl9wYXJzZShpbnB1dFZhbHVlLCBpbmZvKTtcbiAgICAgICAgaWYgKHZhbHVlUmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgIHBhdGhJdGVtID0gcGF0aEl0ZW0gfHwge1xuICAgICAgICAgICAgdHlwZTogXCJtYXBcIixcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAga2V5OiBpbnB1dEtleSxcbiAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlUmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgIGlzc3VlcyA9IHZhbHVlUmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZm8/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFrZXlSZXN1bHQudHlwZWQgfHwgIXZhbHVlUmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQuc2V0KGtleVJlc3VsdC5vdXRwdXQsIHZhbHVlUmVzdWx0Lm91dHB1dCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZWQpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHQob3V0cHV0LCB0aGlzLnBpcGUsIGluZm8sIFwibWFwXCIsIGlzc3Vlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VSZXN1bHQoZmFsc2UsIG91dHB1dCwgaXNzdWVzKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL21hcC9tYXBBc3luYy50c1xuZnVuY3Rpb24gbWFwQXN5bmMoa2V5LCB2YWx1ZTIsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW21lc3NhZ2UgPSBcIkludmFsaWQgdHlwZVwiLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzMsIGFyZzQpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibWFwXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAga2V5LFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBNYXApKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJtYXBcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICBsZXQgdHlwZWQgPSB0cnVlO1xuICAgICAgbGV0IGlzc3VlcztcbiAgICAgIGNvbnN0IG91dHB1dCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgQXJyYXkuZnJvbShpbnB1dC5lbnRyaWVzKCkpLm1hcChhc3luYyAoW2lucHV0S2V5LCBpbnB1dFZhbHVlXSkgPT4ge1xuICAgICAgICAgIGxldCBwYXRoSXRlbTtcbiAgICAgICAgICBjb25zdCBba2V5UmVzdWx0LCB2YWx1ZVJlc3VsdF0gPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgeyBzY2hlbWE6IHRoaXMua2V5LCB2YWx1ZTogaW5wdXRLZXksIG9yaWdpbjogXCJrZXlcIiB9LFxuICAgICAgICAgICAgICB7IHNjaGVtYTogdGhpcy52YWx1ZSwgdmFsdWU6IGlucHV0VmFsdWUsIG9yaWdpbjogXCJ2YWx1ZVwiIH1cbiAgICAgICAgICAgIF0ubWFwKGFzeW5jICh7IHNjaGVtYSwgdmFsdWU6IHZhbHVlMywgb3JpZ2luIH0pID0+IHtcbiAgICAgICAgICAgICAgaWYgKCEoaW5mbz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2NoZW1hLl9wYXJzZSh2YWx1ZTMsIHtcbiAgICAgICAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgICAgICAgIGFib3J0RWFybHk6IGluZm8/LmFib3J0RWFybHksXG4gICAgICAgICAgICAgICAgICBhYm9ydFBpcGVFYXJseTogaW5mbz8uYWJvcnRQaXBlRWFybHksXG4gICAgICAgICAgICAgICAgICBza2lwUGlwZTogaW5mbz8uc2tpcFBpcGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIShpbmZvPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhJdGVtID0gcGF0aEl0ZW0gfHwge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibWFwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAga2V5OiBpbnB1dEtleSxcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKS5jYXRjaCgoKSA9PiBbXSk7XG4gICAgICAgICAgaWYgKCFrZXlSZXN1bHQ/LnR5cGVkIHx8ICF2YWx1ZVJlc3VsdD8udHlwZWQpIHtcbiAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrZXlSZXN1bHQgJiYgdmFsdWVSZXN1bHQpIHtcbiAgICAgICAgICAgIG91dHB1dC5zZXQoa2V5UmVzdWx0Lm91dHB1dCwgdmFsdWVSZXN1bHQub3V0cHV0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgaWYgKHR5cGVkKSB7XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmMob3V0cHV0LCB0aGlzLnBpcGUsIGluZm8sIFwibWFwXCIsIGlzc3Vlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VSZXN1bHQoZmFsc2UsIG91dHB1dCwgaXNzdWVzKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25hbi9uYW4udHNcbmZ1bmN0aW9uIG5hbihtZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibmFuXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoIU51bWJlci5pc05hTihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcIm5hblwiLCB0aGlzLm1lc3NhZ2UsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZVJlc3VsdCh0cnVlLCBpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9uYW4vbmFuQXN5bmMudHNcbmZ1bmN0aW9uIG5hbkFzeW5jKG1lc3NhZ2UgPSBcIkludmFsaWQgdHlwZVwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJuYW5cIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJuYW5cIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbmV2ZXIvbmV2ZXIudHNcbmZ1bmN0aW9uIG5ldmVyKG1lc3NhZ2UgPSBcIkludmFsaWQgdHlwZVwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJuZXZlclwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcIm5ldmVyXCIsIHRoaXMubWVzc2FnZSwgaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbmV2ZXIvbmV2ZXJBc3luYy50c1xuZnVuY3Rpb24gbmV2ZXJBc3luYyhtZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibmV2ZXJcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcIm5ldmVyXCIsIHRoaXMubWVzc2FnZSwgaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbm9uTnVsbGFibGUvbm9uTnVsbGFibGUudHNcbmZ1bmN0aW9uIG5vbk51bGxhYmxlKHdyYXBwZWQsIG1lc3NhZ2UgPSBcIkludmFsaWQgdHlwZVwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJub25fbnVsbGFibGVcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgd3JhcHBlZCxcbiAgICBtZXNzYWdlLFxuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJub25fbnVsbGFibGVcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ub25OdWxsYWJsZS9ub25OdWxsYWJsZUFzeW5jLnRzXG5mdW5jdGlvbiBub25OdWxsYWJsZUFzeW5jKHdyYXBwZWQsIG1lc3NhZ2UgPSBcIkludmFsaWQgdHlwZVwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJub25fbnVsbGFibGVcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICB3cmFwcGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcIm5vbl9udWxsYWJsZVwiLCB0aGlzLm1lc3NhZ2UsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWQuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25vbk51bGxpc2gvbm9uTnVsbGlzaC50c1xuZnVuY3Rpb24gbm9uTnVsbGlzaCh3cmFwcGVkLCBtZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibm9uX251bGxpc2hcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgd3JhcHBlZCxcbiAgICBtZXNzYWdlLFxuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcIm5vbl9udWxsaXNoXCIsIHRoaXMubWVzc2FnZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcGFyc2UoaW5wdXQsIGluZm8pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbm9uTnVsbGlzaC9ub25OdWxsaXNoQXN5bmMudHNcbmZ1bmN0aW9uIG5vbk51bGxpc2hBc3luYyh3cmFwcGVkLCBtZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibm9uX251bGxpc2hcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICB3cmFwcGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUoaW5mbywgXCJ0eXBlXCIsIFwibm9uX251bGxpc2hcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ub25PcHRpb25hbC9ub25PcHRpb25hbC50c1xuZnVuY3Rpb24gbm9uT3B0aW9uYWwod3JhcHBlZCwgbWVzc2FnZSA9IFwiSW52YWxpZCB0eXBlXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm5vbl9vcHRpb25hbFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICB3cmFwcGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoaW5wdXQgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUoaW5mbywgXCJ0eXBlXCIsIFwibm9uX29wdGlvbmFsXCIsIHRoaXMubWVzc2FnZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcGFyc2UoaW5wdXQsIGluZm8pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbm9uT3B0aW9uYWwvbm9uT3B0aW9uYWxBc3luYy50c1xuZnVuY3Rpb24gbm9uT3B0aW9uYWxBc3luYyh3cmFwcGVkLCBtZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibm9uX29wdGlvbmFsXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgd3JhcHBlZCxcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKGlucHV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcIm5vbl9vcHRpb25hbFwiLCB0aGlzLm1lc3NhZ2UsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWQuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL251bGxhYmxlL251bGxhYmxlLnRzXG5mdW5jdGlvbiBudWxsYWJsZSh3cmFwcGVkLCBkZWZhdWx0Xykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibnVsbGFibGVcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgd3JhcHBlZCxcbiAgICBkZWZhdWx0OiBkZWZhdWx0XyxcbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBvdmVycmlkZSA9IGdldERlZmF1bHQodGhpcyk7XG4gICAgICAgIGlmIChvdmVycmlkZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IG92ZXJyaWRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcGFyc2UoaW5wdXQsIGluZm8pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbnVsbGFibGUvbnVsbGFibGVBc3luYy50c1xuZnVuY3Rpb24gbnVsbGFibGVBc3luYyh3cmFwcGVkLCBkZWZhdWx0Xykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibnVsbGFibGVcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICB3cmFwcGVkLFxuICAgIGRlZmF1bHQ6IGRlZmF1bHRfLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG92ZXJyaWRlID0gYXdhaXQgZ2V0RGVmYXVsdEFzeW5jKHRoaXMpO1xuICAgICAgICBpZiAob3ZlcnJpZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZVJlc3VsdCh0cnVlLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQgPSBvdmVycmlkZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWQuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL251bGxpc2gvbnVsbGlzaC50c1xuZnVuY3Rpb24gbnVsbGlzaCh3cmFwcGVkLCBkZWZhdWx0Xykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibnVsbGlzaFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICB3cmFwcGVkLFxuICAgIGRlZmF1bHQ6IGRlZmF1bHRfLFxuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3Qgb3ZlcnJpZGUgPSBnZXREZWZhdWx0KHRoaXMpO1xuICAgICAgICBpZiAob3ZlcnJpZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZVJlc3VsdCh0cnVlLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQgPSBvdmVycmlkZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWQuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL251bGxpc2gvbnVsbGlzaEFzeW5jLnRzXG5mdW5jdGlvbiBudWxsaXNoQXN5bmMod3JhcHBlZCwgZGVmYXVsdF8pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm51bGxpc2hcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICB3cmFwcGVkLFxuICAgIGRlZmF1bHQ6IGRlZmF1bHRfLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3Qgb3ZlcnJpZGUgPSBhd2FpdCBnZXREZWZhdWx0QXN5bmModGhpcyk7XG4gICAgICAgIGlmIChvdmVycmlkZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IG92ZXJyaWRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcGFyc2UoaW5wdXQsIGluZm8pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbnVsbC9udWxsLnRzXG5mdW5jdGlvbiBudWxsXyhtZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibnVsbFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKGlucHV0ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJudWxsXCIsIHRoaXMubWVzc2FnZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICB9XG4gIH07XG59XG52YXIgbnVsbFR5cGUgPSBudWxsXztcblxuLy8gc3JjL3NjaGVtYXMvbnVsbC9udWxsQXN5bmMudHNcbmZ1bmN0aW9uIG51bGxBc3luYyhtZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibnVsbFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoaW5wdXQgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcIm51bGxcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cbnZhciBudWxsVHlwZUFzeW5jID0gbnVsbEFzeW5jO1xuXG4vLyBzcmMvc2NoZW1hcy9udW1iZXIvbnVtYmVyLnRzXG5mdW5jdGlvbiBudW1iZXIoYXJnMSwgYXJnMikge1xuICBjb25zdCBbbWVzc2FnZSA9IFwiSW52YWxpZCB0eXBlXCIsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMSwgYXJnMik7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJudW1iZXJcIiB8fCBpc05hTihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcIm51bWJlclwiLCB0aGlzLm1lc3NhZ2UsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwaXBlUmVzdWx0KGlucHV0LCB0aGlzLnBpcGUsIGluZm8sIFwibnVtYmVyXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbnVtYmVyL251bWJlckFzeW5jLnRzXG5mdW5jdGlvbiBudW1iZXJBc3luYyhhcmcxLCBhcmcyKSB7XG4gIGNvbnN0IFttZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIiwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcxLCBhcmcyKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwibnVtYmVyXCIgfHwgaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJudW1iZXJcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGlwZVJlc3VsdEFzeW5jKGlucHV0LCB0aGlzLnBpcGUsIGluZm8sIFwibnVtYmVyXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvb2JqZWN0L29iamVjdC50c1xuZnVuY3Rpb24gb2JqZWN0KGVudHJpZXMsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW3Jlc3QsIG1lc3NhZ2UgPSBcIkludmFsaWQgdHlwZVwiLCBwaXBlXSA9IHJlc3RBbmREZWZhdWx0QXJncyhhcmcyLCBhcmczLCBhcmc0KTtcbiAgbGV0IGNhY2hlZEVudHJpZXM7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZW50cmllcyxcbiAgICByZXN0LFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJvYmplY3RcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICBjYWNoZWRFbnRyaWVzID0gY2FjaGVkRW50cmllcyB8fCBPYmplY3QuZW50cmllcyh0aGlzLmVudHJpZXMpO1xuICAgICAgbGV0IHR5cGVkID0gdHJ1ZTtcbiAgICAgIGxldCBpc3N1ZXM7XG4gICAgICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgc2NoZW1hXSBvZiBjYWNoZWRFbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHNjaGVtYS5fcGFyc2UodmFsdWUyLCBpbmZvKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgcmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgIGlzc3VlcyA9IHJlc3VsdC5pc3N1ZXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmZvPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0Lm91dHB1dCAhPT0gdm9pZCAwIHx8IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgIG91dHB1dFtrZXldID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVzdCAmJiAhKGluZm8/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgIGlmICghKGtleSBpbiB0aGlzLmVudHJpZXMpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN0Ll9wYXJzZSh2YWx1ZTIsIGluZm8pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpbmZvPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlZCkge1xuICAgICAgICByZXR1cm4gcGlwZVJlc3VsdChcbiAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgdGhpcy5waXBlLFxuICAgICAgICAgIGluZm8sXG4gICAgICAgICAgXCJvYmplY3RcIixcbiAgICAgICAgICBpc3N1ZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZVJlc3VsdChmYWxzZSwgb3V0cHV0LCBpc3N1ZXMpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvb2JqZWN0L29iamVjdEFzeW5jLnRzXG5mdW5jdGlvbiBvYmplY3RBc3luYyhlbnRyaWVzLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFtyZXN0LCBtZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIiwgcGlwZV0gPSByZXN0QW5kRGVmYXVsdEFyZ3MoYXJnMiwgYXJnMywgYXJnNCk7XG4gIGxldCBjYWNoZWRFbnRyaWVzO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgZW50cmllcyxcbiAgICByZXN0LFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJvYmplY3RcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICBjYWNoZWRFbnRyaWVzID0gY2FjaGVkRW50cmllcyB8fCBPYmplY3QuZW50cmllcyh0aGlzLmVudHJpZXMpO1xuICAgICAgbGV0IHR5cGVkID0gdHJ1ZTtcbiAgICAgIGxldCBpc3N1ZXM7XG4gICAgICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgY2FjaGVkRW50cmllcy5tYXAoYXN5bmMgKFtrZXksIHNjaGVtYV0pID0+IHtcbiAgICAgICAgICAgIGlmICghKGluZm8/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzY2hlbWEuX3BhcnNlKHZhbHVlMiwgaW5mbyk7XG4gICAgICAgICAgICAgIGlmICghKGluZm8/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgcmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlcyA9IHJlc3VsdC5pc3N1ZXM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoaW5mbz8uYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC50eXBlZCkge1xuICAgICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5vdXRwdXQgIT09IHZvaWQgMCB8fCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICB0aGlzLnJlc3QgJiYgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoaW5wdXQpLm1hcChhc3luYyAoW2tleSwgdmFsdWUyXSkgPT4ge1xuICAgICAgICAgICAgaWYgKCEoaW5mbz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgIGlmICghKGtleSBpbiB0aGlzLmVudHJpZXMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZXN0Ll9wYXJzZSh2YWx1ZTIsIGluZm8pO1xuICAgICAgICAgICAgICAgIGlmICghKGluZm8/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC50eXBlZCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSByZXN1bHQub3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIF0pLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgaWYgKHR5cGVkKSB7XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmMoXG4gICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgIHRoaXMucGlwZSxcbiAgICAgICAgICBpbmZvLFxuICAgICAgICAgIFwib2JqZWN0XCIsXG4gICAgICAgICAgaXNzdWVzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VSZXN1bHQoZmFsc2UsIG91dHB1dCwgaXNzdWVzKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL29wdGlvbmFsL29wdGlvbmFsLnRzXG5mdW5jdGlvbiBvcHRpb25hbCh3cmFwcGVkLCBkZWZhdWx0Xykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwib3B0aW9uYWxcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgd3JhcHBlZCxcbiAgICBkZWZhdWx0OiBkZWZhdWx0XyxcbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IG92ZXJyaWRlID0gZ2V0RGVmYXVsdCh0aGlzKTtcbiAgICAgICAgaWYgKG92ZXJyaWRlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gb3ZlcnJpZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9vcHRpb25hbC9vcHRpb25hbEFzeW5jLnRzXG5mdW5jdGlvbiBvcHRpb25hbEFzeW5jKHdyYXBwZWQsIGRlZmF1bHRfKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJvcHRpb25hbFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgZGVmYXVsdDogZGVmYXVsdF8sXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoaW5wdXQgPT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBvdmVycmlkZSA9IGF3YWl0IGdldERlZmF1bHRBc3luYyh0aGlzKTtcbiAgICAgICAgaWYgKG92ZXJyaWRlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gb3ZlcnJpZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9waWNrbGlzdC9waWNrbGlzdC50c1xuZnVuY3Rpb24gcGlja2xpc3Qob3B0aW9ucywgbWVzc2FnZSA9IFwiSW52YWxpZCB0eXBlXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInBpY2tsaXN0XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmluY2x1ZGVzKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUoaW5mbywgXCJ0eXBlXCIsIFwicGlja2xpc3RcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cbnZhciBlbnVtVHlwZSA9IHBpY2tsaXN0O1xuXG4vLyBzcmMvc2NoZW1hcy9waWNrbGlzdC9waWNrbGlzdEFzeW5jLnRzXG5mdW5jdGlvbiBwaWNrbGlzdEFzeW5jKG9wdGlvbnMsIG1lc3NhZ2UgPSBcIkludmFsaWQgdHlwZVwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJwaWNrbGlzdFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmluY2x1ZGVzKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUoaW5mbywgXCJ0eXBlXCIsIFwicGlja2xpc3RcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cbnZhciBlbnVtVHlwZUFzeW5jID0gcGlja2xpc3RBc3luYztcblxuLy8gc3JjL3NjaGVtYXMvc3RyaW5nL3N0cmluZy50c1xuZnVuY3Rpb24gc3RyaW5nKGFyZzEsIGFyZzIpIHtcbiAgY29uc3QgW21lc3NhZ2UgPSBcIkludmFsaWQgdHlwZVwiLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzEsIGFyZzIpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcInN0cmluZ1wiLCB0aGlzLm1lc3NhZ2UsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwaXBlUmVzdWx0KGlucHV0LCB0aGlzLnBpcGUsIGluZm8sIFwic3RyaW5nXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvc3RyaW5nL3N0cmluZ0FzeW5jLnRzXG5mdW5jdGlvbiBzdHJpbmdBc3luYyhhcmcxLCBhcmcyKSB7XG4gIGNvbnN0IFttZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIiwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcxLCBhcmcyKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcInN0cmluZ1wiLCB0aGlzLm1lc3NhZ2UsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmMoaW5wdXQsIHRoaXMucGlwZSwgaW5mbywgXCJzdHJpbmdcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9yZWNvcmQvdXRpbHMvcmVjb3JkQXJncy9yZWNvcmRBcmdzLnRzXG5mdW5jdGlvbiByZWNvcmRBcmdzKGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgaWYgKHR5cGVvZiBhcmcyID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGFyZzIpKSB7XG4gICAgY29uc3QgW21lc3NhZ2UyLCBwaXBlMl0gPSBkZWZhdWx0QXJncyhhcmczLCBhcmc0KTtcbiAgICByZXR1cm4gW2FyZzEsIGFyZzIsIG1lc3NhZ2UyLCBwaXBlMl07XG4gIH1cbiAgY29uc3QgW21lc3NhZ2UsIHBpcGVdID0gZGVmYXVsdEFyZ3MoXG4gICAgYXJnMixcbiAgICBhcmczXG4gICk7XG4gIHJldHVybiBbc3RyaW5nKCksIGFyZzEsIG1lc3NhZ2UsIHBpcGVdO1xufVxuXG4vLyBzcmMvc2NoZW1hcy9yZWNvcmQvdmFsdWVzLnRzXG52YXIgQkxPQ0tFRF9LRVlTID0gW1wiX19wcm90b19fXCIsIFwicHJvdG90eXBlXCIsIFwiY29uc3RydWN0b3JcIl07XG5cbi8vIHNyYy9zY2hlbWFzL3JlY29yZC9yZWNvcmQudHNcbmZ1bmN0aW9uIHJlY29yZChhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFtrZXksIHZhbHVlMiwgbWVzc2FnZSA9IFwiSW52YWxpZCB0eXBlXCIsIHBpcGVdID0gcmVjb3JkQXJncyhhcmcxLCBhcmcyLCBhcmczLCBhcmc0KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInJlY29yZFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBrZXksXG4gICAgdmFsdWU6IHZhbHVlMixcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoIWlucHV0IHx8IHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUoaW5mbywgXCJ0eXBlXCIsIFwicmVjb3JkXCIsIHRoaXMubWVzc2FnZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgbGV0IHR5cGVkID0gdHJ1ZTtcbiAgICAgIGxldCBpc3N1ZXM7XG4gICAgICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgW2lucHV0S2V5LCBpbnB1dFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhpbnB1dCkpIHtcbiAgICAgICAgaWYgKCFCTE9DS0VEX0tFWVMuaW5jbHVkZXMoaW5wdXRLZXkpKSB7XG4gICAgICAgICAgbGV0IHBhdGhJdGVtO1xuICAgICAgICAgIGNvbnN0IGtleVJlc3VsdCA9IHRoaXMua2V5Ll9wYXJzZShpbnB1dEtleSwge1xuICAgICAgICAgICAgb3JpZ2luOiBcImtleVwiLFxuICAgICAgICAgICAgYWJvcnRFYXJseTogaW5mbz8uYWJvcnRFYXJseSxcbiAgICAgICAgICAgIGFib3J0UGlwZUVhcmx5OiBpbmZvPy5hYm9ydFBpcGVFYXJseSxcbiAgICAgICAgICAgIHNraXBQaXBlOiBpbmZvPy5za2lwUGlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChrZXlSZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJyZWNvcmRcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogaW5wdXRLZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBrZXlSZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaXNzdWVzID0ga2V5UmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmZvPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB2YWx1ZVJlc3VsdCA9IHRoaXMudmFsdWUuX3BhcnNlKGlucHV0VmFsdWUsIGluZm8pO1xuICAgICAgICAgIGlmICh2YWx1ZVJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIHBhdGhJdGVtID0gcGF0aEl0ZW0gfHwge1xuICAgICAgICAgICAgICB0eXBlOiBcInJlY29yZFwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5OiBpbnB1dEtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IGlucHV0VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlUmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlzc3VlcyA9IHZhbHVlUmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmZvPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWtleVJlc3VsdC50eXBlZCB8fCAhdmFsdWVSZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrZXlSZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICAgIG91dHB1dFtrZXlSZXN1bHQub3V0cHV0XSA9IHZhbHVlUmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlZCkge1xuICAgICAgICByZXR1cm4gcGlwZVJlc3VsdChcbiAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgdGhpcy5waXBlLFxuICAgICAgICAgIGluZm8sXG4gICAgICAgICAgXCJyZWNvcmRcIixcbiAgICAgICAgICBpc3N1ZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZVJlc3VsdChmYWxzZSwgb3V0cHV0LCBpc3N1ZXMpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvcmVjb3JkL3JlY29yZEFzeW5jLnRzXG5mdW5jdGlvbiByZWNvcmRBc3luYyhhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFtrZXksIHZhbHVlMiwgbWVzc2FnZSA9IFwiSW52YWxpZCB0eXBlXCIsIHBpcGVdID0gcmVjb3JkQXJncyhhcmcxLCBhcmcyLCBhcmczLCBhcmc0KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInJlY29yZFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGtleSxcbiAgICB2YWx1ZTogdmFsdWUyLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJyZWNvcmRcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICBsZXQgdHlwZWQgPSB0cnVlO1xuICAgICAgbGV0IGlzc3VlcztcbiAgICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIC8vIE5vdGU6IGBPYmplY3QuZW50cmllcyguLi4pYCBjb252ZXJ0cyBlYWNoIGtleSB0byBhIHN0cmluZ1xuICAgICAgICBPYmplY3QuZW50cmllcyhpbnB1dCkubWFwKGFzeW5jIChbaW5wdXRLZXksIGlucHV0VmFsdWVdKSA9PiB7XG4gICAgICAgICAgaWYgKCFCTE9DS0VEX0tFWVMuaW5jbHVkZXMoaW5wdXRLZXkpKSB7XG4gICAgICAgICAgICBsZXQgcGF0aEl0ZW07XG4gICAgICAgICAgICBjb25zdCBba2V5UmVzdWx0LCB2YWx1ZVJlc3VsdF0gPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIHsgc2NoZW1hOiB0aGlzLmtleSwgdmFsdWU6IGlucHV0S2V5LCBvcmlnaW46IFwia2V5XCIgfSxcbiAgICAgICAgICAgICAgICB7IHNjaGVtYTogdGhpcy52YWx1ZSwgdmFsdWU6IGlucHV0VmFsdWUsIG9yaWdpbjogXCJ2YWx1ZVwiIH1cbiAgICAgICAgICAgICAgXS5tYXAoYXN5bmMgKHsgc2NoZW1hLCB2YWx1ZTogdmFsdWUzLCBvcmlnaW4gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghKGluZm8/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2NoZW1hLl9wYXJzZSh2YWx1ZTMsIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBhYm9ydEVhcmx5OiBpbmZvPy5hYm9ydEVhcmx5LFxuICAgICAgICAgICAgICAgICAgICBhYm9ydFBpcGVFYXJseTogaW5mbz8uYWJvcnRQaXBlRWFybHksXG4gICAgICAgICAgICAgICAgICAgIHNraXBQaXBlOiBpbmZvPy5za2lwUGlwZVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIShpbmZvPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwYXRoSXRlbSA9IHBhdGhJdGVtIHx8IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVjb3JkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogaW5wdXRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKS5jYXRjaCgoKSA9PiBbXSk7XG4gICAgICAgICAgICBpZiAoIWtleVJlc3VsdD8udHlwZWQgfHwgIXZhbHVlUmVzdWx0Py50eXBlZCkge1xuICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleVJlc3VsdD8udHlwZWQgJiYgdmFsdWVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgb3V0cHV0W2tleVJlc3VsdC5vdXRwdXRdID0gdmFsdWVSZXN1bHQub3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBpZiAodHlwZWQpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyhcbiAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgdGhpcy5waXBlLFxuICAgICAgICAgIGluZm8sXG4gICAgICAgICAgXCJyZWNvcmRcIixcbiAgICAgICAgICBpc3N1ZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZVJlc3VsdChmYWxzZSwgb3V0cHV0LCBpc3N1ZXMpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvcmVjdXJzaXZlL3JlY3Vyc2l2ZS50c1xuZnVuY3Rpb24gcmVjdXJzaXZlKGdldHRlcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicmVjdXJzaXZlXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGdldHRlcixcbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIHJldHVybiB0aGlzLmdldHRlcigpLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9yZWN1cnNpdmUvcmVjdXJzaXZlQXN5bmMudHNcbmZ1bmN0aW9uIHJlY3Vyc2l2ZUFzeW5jKGdldHRlcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicmVjdXJzaXZlXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgZ2V0dGVyLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0dGVyKCkuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3NldC9zZXQudHNcbmZ1bmN0aW9uIHNldCh2YWx1ZTIsIGFyZzIsIGFyZzMpIHtcbiAgY29uc3QgW21lc3NhZ2UgPSBcIkludmFsaWQgdHlwZVwiLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzIsIGFyZzMpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic2V0XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBTZXQpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJzZXRcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICBsZXQga2V5ID0gMDtcbiAgICAgIGxldCB0eXBlZCA9IHRydWU7XG4gICAgICBsZXQgaXNzdWVzO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGZvciAoY29uc3QgaW5wdXRWYWx1ZSBvZiBpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnZhbHVlLl9wYXJzZShpbnB1dFZhbHVlLCBpbmZvKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNzdWVzKSB7XG4gICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5mbz8uYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdC50eXBlZCkge1xuICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LmFkZChyZXN1bHQub3V0cHV0KTtcbiAgICAgICAga2V5Kys7XG4gICAgICB9XG4gICAgICBpZiAodHlwZWQpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHQob3V0cHV0LCB0aGlzLnBpcGUsIGluZm8sIFwic2V0XCIsIGlzc3Vlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VSZXN1bHQoZmFsc2UsIG91dHB1dCwgaXNzdWVzKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3NldC9zZXRBc3luYy50c1xuZnVuY3Rpb24gc2V0QXN5bmModmFsdWUyLCBhcmcyLCBhcmczKSB7XG4gIGNvbnN0IFttZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIiwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcyLCBhcmczKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInNldFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBTZXQpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJzZXRcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICBsZXQgdHlwZWQgPSB0cnVlO1xuICAgICAgbGV0IGlzc3VlcztcbiAgICAgIGNvbnN0IG91dHB1dCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgQXJyYXkuZnJvbShpbnB1dC52YWx1ZXMoKSkubWFwKGFzeW5jIChpbnB1dFZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICBpZiAoIShpbmZvPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudmFsdWUuX3BhcnNlKGlucHV0VmFsdWUsIGluZm8pO1xuICAgICAgICAgICAgaWYgKCEoaW5mbz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZm8/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXJlc3VsdC50eXBlZCkge1xuICAgICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3V0cHV0LmFkZChyZXN1bHQub3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgaWYgKHR5cGVkKSB7XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmMob3V0cHV0LCB0aGlzLnBpcGUsIGluZm8sIFwic2V0XCIsIGlzc3Vlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VSZXN1bHQoZmFsc2UsIG91dHB1dCwgaXNzdWVzKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3NwZWNpYWwvc3BlY2lhbC50c1xuZnVuY3Rpb24gc3BlY2lhbChjaGVjaywgYXJnMiwgYXJnMykge1xuICBjb25zdCBbbWVzc2FnZSA9IFwiSW52YWxpZCB0eXBlXCIsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMiwgYXJnMyk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzcGVjaWFsXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGNoZWNrLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghdGhpcy5jaGVjayhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcInNwZWNpYWxcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGlwZVJlc3VsdChpbnB1dCwgdGhpcy5waXBlLCBpbmZvLCBcInNwZWNpYWxcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zcGVjaWFsL3NwZWNpYWxBc3luYy50c1xuZnVuY3Rpb24gc3BlY2lhbEFzeW5jKGNoZWNrLCBhcmcyLCBhcmczKSB7XG4gIGNvbnN0IFttZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIiwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcyLCBhcmczKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInNwZWNpYWxcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBjaGVjayxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAoIWF3YWl0IHRoaXMuY2hlY2soaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJzcGVjaWFsXCIsIHRoaXMubWVzc2FnZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyhpbnB1dCwgdGhpcy5waXBlLCBpbmZvLCBcInNwZWNpYWxcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zeW1ib2wvc3ltYm9sLnRzXG5mdW5jdGlvbiBzeW1ib2wobWVzc2FnZSA9IFwiSW52YWxpZCB0eXBlXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInN5bWJvbFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJzeW1ib2xcIikge1xuICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUoaW5mbywgXCJ0eXBlXCIsIFwic3ltYm9sXCIsIHRoaXMubWVzc2FnZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3N5bWJvbC9zeW1ib2xBc3luYy50c1xuZnVuY3Rpb24gc3ltYm9sQXN5bmMobWVzc2FnZSA9IFwiSW52YWxpZCB0eXBlXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInN5bWJvbFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJzeW1ib2xcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdHVwbGUvdHVwbGUudHNcbmZ1bmN0aW9uIHR1cGxlKGl0ZW1zLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFtyZXN0LCBtZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIiwgcGlwZV0gPSByZXN0QW5kRGVmYXVsdEFyZ3MoYXJnMiwgYXJnMywgYXJnNCk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBpdGVtcyxcbiAgICByZXN0LFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgdGhpcy5pdGVtcy5sZW5ndGggPiBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKGluZm8sIFwidHlwZVwiLCBcInR1cGxlXCIsIHRoaXMubWVzc2FnZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgbGV0IHR5cGVkID0gdHJ1ZTtcbiAgICAgIGxldCBpc3N1ZXM7XG4gICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgIGZvciAobGV0IGtleSA9IDA7IGtleSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLml0ZW1zW2tleV0uX3BhcnNlKHZhbHVlMiwgaW5mbyk7XG4gICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgcmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgIGlzc3VlcyA9IHJlc3VsdC5pc3N1ZXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmZvPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRba2V5XSA9IHJlc3VsdC5vdXRwdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZXN0ICYmICEoaW5mbz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgIGZvciAobGV0IGtleSA9IHRoaXMuaXRlbXMubGVuZ3RoOyBrZXkgPCBpbnB1dC5sZW5ndGg7IGtleSsrKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlc3QuX3BhcnNlKHZhbHVlMiwgaW5mbyk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZm8/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXRba2V5XSA9IHJlc3VsdC5vdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlZCkge1xuICAgICAgICByZXR1cm4gcGlwZVJlc3VsdChcbiAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgdGhpcy5waXBlLFxuICAgICAgICAgIGluZm8sXG4gICAgICAgICAgXCJ0dXBsZVwiLFxuICAgICAgICAgIGlzc3Vlc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0KGZhbHNlLCBvdXRwdXQsIGlzc3Vlcyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy90dXBsZS90dXBsZUFzeW5jLnRzXG5mdW5jdGlvbiB0dXBsZUFzeW5jKGl0ZW1zLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFtyZXN0LCBtZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIiwgcGlwZV0gPSByZXN0QW5kRGVmYXVsdEFyZ3MoYXJnMiwgYXJnMywgYXJnNCk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGl0ZW1zLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCB0aGlzLml0ZW1zLmxlbmd0aCA+IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUoaW5mbywgXCJ0eXBlXCIsIFwidHVwbGVcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICBsZXQgdHlwZWQgPSB0cnVlO1xuICAgICAgbGV0IGlzc3VlcztcbiAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAvLyBQYXJzZSBzY2hlbWEgb2YgZWFjaCB0dXBsZSBpdGVtXG4gICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgIHRoaXMuaXRlbXMubWFwKGFzeW5jIChzY2hlbWEsIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKCEoaW5mbz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNjaGVtYS5fcGFyc2UodmFsdWUyLCBpbmZvKTtcbiAgICAgICAgICAgICAgaWYgKCEoaW5mbz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGluZm8/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICAgIC8vIElmIG5lY2Vzc2FyeSBwYXJzZSBzY2hlbWEgb2YgZWFjaCByZXN0IGl0ZW1cbiAgICAgICAgdGhpcy5yZXN0ICYmIFByb21pc2UuYWxsKFxuICAgICAgICAgIGlucHV0LnNsaWNlKHRoaXMuaXRlbXMubGVuZ3RoKS5tYXAoYXN5bmMgKHZhbHVlMiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmICghKGluZm8/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLml0ZW1zLmxlbmd0aCArIGluZGV4O1xuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlc3QuX3BhcnNlKHZhbHVlMiwgaW5mbyk7XG4gICAgICAgICAgICAgIGlmICghKGluZm8/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IHJlc3VsdC5vdXRwdXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICBdKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICAgIGlmICh0eXBlZCkge1xuICAgICAgICByZXR1cm4gcGlwZVJlc3VsdEFzeW5jKFxuICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICB0aGlzLnBpcGUsXG4gICAgICAgICAgaW5mbyxcbiAgICAgICAgICBcInR1cGxlXCIsXG4gICAgICAgICAgaXNzdWVzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VSZXN1bHQoZmFsc2UsIG91dHB1dCwgaXNzdWVzKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3VuZGVmaW5lZC91bmRlZmluZWQudHNcbmZ1bmN0aW9uIHVuZGVmaW5lZF8obWVzc2FnZSA9IFwiSW52YWxpZCB0eXBlXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInVuZGVmaW5lZFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUoaW5mbywgXCJ0eXBlXCIsIFwidW5kZWZpbmVkXCIsIHRoaXMubWVzc2FnZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICB9XG4gIH07XG59XG52YXIgdW5kZWZpbmVkVHlwZSA9IHVuZGVmaW5lZF87XG5cbi8vIHNyYy9zY2hlbWFzL3VuZGVmaW5lZC91bmRlZmluZWRBc3luYy50c1xuZnVuY3Rpb24gdW5kZWZpbmVkQXN5bmMobWVzc2FnZSA9IFwiSW52YWxpZCB0eXBlXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInVuZGVmaW5lZFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJ1bmRlZmluZWRcIiwgdGhpcy5tZXNzYWdlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cbnZhciB1bmRlZmluZWRUeXBlQXN5bmMgPSB1bmRlZmluZWRBc3luYztcblxuLy8gc3JjL3NjaGVtYXMvdW5pb24vdW5pb24udHNcbmZ1bmN0aW9uIHVuaW9uKG9wdGlvbnMsIGFyZzIsIGFyZzMpIHtcbiAgY29uc3QgW21lc3NhZ2UgPSBcIkludmFsaWQgdHlwZVwiLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzIsIGFyZzMpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBsZXQgaXNzdWVzO1xuICAgICAgbGV0IG91dHB1dDtcbiAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHRoaXMub3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICBpZiAoaXNzdWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaXNzdWVzLnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQgPSBbcmVzdWx0Lm91dHB1dF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHQob3V0cHV0WzBdLCB0aGlzLnBpcGUsIGluZm8sIFwidW5pb25cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUoXG4gICAgICAgIGluZm8sXG4gICAgICAgIFwidHlwZVwiLFxuICAgICAgICBcInVuaW9uXCIsXG4gICAgICAgIHRoaXMubWVzc2FnZSxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgaXNzdWVzXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdW5pb24vdW5pb25Bc3luYy50c1xuZnVuY3Rpb24gdW5pb25Bc3luYyhvcHRpb25zLCBhcmcyLCBhcmczKSB7XG4gIGNvbnN0IFttZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIiwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcyLCBhcmczKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBsZXQgaXNzdWVzO1xuICAgICAgbGV0IG91dHB1dDtcbiAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHRoaXMub3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzY2hlbWEuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICBpZiAoaXNzdWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaXNzdWVzLnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQgPSBbcmVzdWx0Lm91dHB1dF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyhvdXRwdXRbMF0sIHRoaXMucGlwZSwgaW5mbywgXCJ1bmlvblwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShcbiAgICAgICAgaW5mbyxcbiAgICAgICAgXCJ0eXBlXCIsXG4gICAgICAgIFwidW5pb25cIixcbiAgICAgICAgdGhpcy5tZXNzYWdlLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBpc3N1ZXNcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy91bmtub3duL3Vua25vd24udHNcbmZ1bmN0aW9uIHVua25vd24ocGlwZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidW5rbm93blwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgcmV0dXJuIHBpcGVSZXN1bHQoaW5wdXQsIHRoaXMucGlwZSwgaW5mbywgXCJ1bmtub3duXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdW5rbm93bi91bmtub3duQXN5bmMudHNcbmZ1bmN0aW9uIHVua25vd25Bc3luYyhwaXBlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ1bmtub3duXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgcGlwZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmMoaW5wdXQsIHRoaXMucGlwZSwgaW5mbywgXCJ1bmtub3duXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdmFyaWFudC92YXJpYW50LnRzXG5mdW5jdGlvbiB2YXJpYW50KGtleSwgb3B0aW9ucywgYXJnMywgYXJnNCkge1xuICBjb25zdCBbbWVzc2FnZSA9IFwiSW52YWxpZCB0eXBlXCIsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMywgYXJnNCk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ2YXJpYW50XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGtleSxcbiAgICBvcHRpb25zLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJ2YXJpYW50XCIsIHRoaXMubWVzc2FnZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMua2V5IGluIGlucHV0KSB7XG4gICAgICAgIGxldCBpc3N1ZXM7XG4gICAgICAgIGxldCBvdXRwdXQ7XG4gICAgICAgIGNvbnN0IHBhcnNlT3B0aW9ucyA9IChvcHRpb25zMikgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIG9wdGlvbnMyKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgY29uc3Qga2V5UmVzdWx0ID0gc2NoZW1hLmVudHJpZXNbdGhpcy5rZXldLl9wYXJzZShcbiAgICAgICAgICAgICAgICBpbnB1dFt0aGlzLmtleV0sXG4gICAgICAgICAgICAgICAgaW5mb1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoIWtleVJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhUmVzdWx0ID0gc2NoZW1hLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFSZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZXMgPSBkYXRhUmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gW2RhdGFSZXN1bHQub3V0cHV0XTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzY2hlbWEudHlwZSA9PT0gXCJ2YXJpYW50XCIpIHtcbiAgICAgICAgICAgICAgcGFyc2VPcHRpb25zKHNjaGVtYS5vcHRpb25zKTtcbiAgICAgICAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwYXJzZU9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIHJldHVybiBwaXBlUmVzdWx0KG91dHB1dFswXSwgdGhpcy5waXBlLCBpbmZvLCBcInZhcmlhbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzc3Vlcykge1xuICAgICAgICAgIHJldHVybiBwYXJzZVJlc3VsdChmYWxzZSwgb3V0cHV0LCBpc3N1ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUoaW5mbywgXCJ0eXBlXCIsIFwidmFyaWFudFwiLCB0aGlzLm1lc3NhZ2UsIGlucHV0LCBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9XG4gICAgICBdKTtcbiAgICB9XG4gIH07XG59XG52YXIgZGlzY3JpbWluYXRlZFVuaW9uID0gdmFyaWFudDtcblxuLy8gc3JjL3NjaGVtYXMvdmFyaWFudC92YXJpYW50QXN5bmMudHNcbmZ1bmN0aW9uIHZhcmlhbnRBc3luYyhrZXksIG9wdGlvbnMsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW21lc3NhZ2UgPSBcIkludmFsaWQgdHlwZVwiLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzMsIGFyZzQpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidmFyaWFudFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGtleSxcbiAgICBvcHRpb25zLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJ2YXJpYW50XCIsIHRoaXMubWVzc2FnZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMua2V5IGluIGlucHV0KSB7XG4gICAgICAgIGxldCBpc3N1ZXM7XG4gICAgICAgIGxldCBvdXRwdXQ7XG4gICAgICAgIGNvbnN0IHBhcnNlT3B0aW9ucyA9IGFzeW5jIChvcHRpb25zMikgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIG9wdGlvbnMyKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgY29uc3Qga2V5UmVzdWx0ID0gYXdhaXQgc2NoZW1hLmVudHJpZXNbdGhpcy5rZXldLl9wYXJzZShcbiAgICAgICAgICAgICAgICBpbnB1dFt0aGlzLmtleV0sXG4gICAgICAgICAgICAgICAgaW5mb1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoIWtleVJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhUmVzdWx0ID0gYXdhaXQgc2NoZW1hLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFSZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZXMgPSBkYXRhUmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gW2RhdGFSZXN1bHQub3V0cHV0XTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzY2hlbWEudHlwZSA9PT0gXCJ2YXJpYW50XCIpIHtcbiAgICAgICAgICAgICAgYXdhaXQgcGFyc2VPcHRpb25zKHNjaGVtYS5vcHRpb25zKTtcbiAgICAgICAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCBwYXJzZU9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmMob3V0cHV0WzBdLCB0aGlzLnBpcGUsIGluZm8sIFwidmFyaWFudFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNzdWVzKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0KGZhbHNlLCBvdXRwdXQsIGlzc3Vlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZShpbmZvLCBcInR5cGVcIiwgXCJ2YXJpYW50XCIsIHRoaXMubWVzc2FnZSwgaW5wdXQsIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgaW5wdXQsXG4gICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH1cbiAgICAgIF0pO1xuICAgIH1cbiAgfTtcbn1cbnZhciBkaXNjcmltaW5hdGVkVW5pb25Bc3luYyA9IHZhcmlhbnRBc3luYztcblxuLy8gc3JjL3NjaGVtYXMvdm9pZC92b2lkLnRzXG5mdW5jdGlvbiB2b2lkXyhtZXNzYWdlID0gXCJJbnZhbGlkIHR5cGVcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidm9pZFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUoaW5mbywgXCJ0eXBlXCIsIFwidm9pZFwiLCB0aGlzLm1lc3NhZ2UsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZVJlc3VsdCh0cnVlLCBpbnB1dCk7XG4gICAgfVxuICB9O1xufVxudmFyIHZvaWRUeXBlID0gdm9pZF87XG5cbi8vIHNyYy9zY2hlbWFzL3ZvaWQvdm9pZEFzeW5jLnRzXG5mdW5jdGlvbiB2b2lkQXN5bmMobWVzc2FnZSA9IFwiSW52YWxpZCB0eXBlXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInZvaWRcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUoaW5mbywgXCJ0eXBlXCIsIFwidm9pZFwiLCB0aGlzLm1lc3NhZ2UsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZVJlc3VsdCh0cnVlLCBpbnB1dCk7XG4gICAgfVxuICB9O1xufVxudmFyIHZvaWRUeXBlQXN5bmMgPSB2b2lkQXN5bmM7XG5cbi8vIHNyYy9tZXRob2RzL2tleW9mL2tleW9mLnRzXG5mdW5jdGlvbiBrZXlvZihzY2hlbWEpIHtcbiAgcmV0dXJuIHBpY2tsaXN0KFxuICAgIE9iamVjdC5rZXlzKHNjaGVtYS5lbnRyaWVzKVxuICApO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9tZXJnZS9tZXJnZS50c1xuZnVuY3Rpb24gbWVyZ2Uoc2NoZW1hcywgYXJnMiwgYXJnMywgYXJnNCkge1xuICBjb25zdCBbcmVzdCwgbWVzc2FnZSwgcGlwZV0gPSByZXN0QW5kRGVmYXVsdEFyZ3MoYXJnMiwgYXJnMywgYXJnNCk7XG4gIHJldHVybiBvYmplY3QoXG4gICAgc2NoZW1hcy5yZWR1Y2UoXG4gICAgICAoZW50cmllcywgc2NoZW1hKSA9PiAoeyAuLi5lbnRyaWVzLCAuLi5zY2hlbWEuZW50cmllcyB9KSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICByZXN0LFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZVxuICApO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9tZXJnZS9tZXJnZUFzeW5jLnRzXG5mdW5jdGlvbiBtZXJnZUFzeW5jKHNjaGVtYXMsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW3Jlc3QsIG1lc3NhZ2UsIHBpcGVdID0gcmVzdEFuZERlZmF1bHRBcmdzKGFyZzIsIGFyZzMsIGFyZzQpO1xuICByZXR1cm4gb2JqZWN0QXN5bmMoXG4gICAgc2NoZW1hcy5yZWR1Y2UoXG4gICAgICAoZW50cmllcywgc2NoZW1hKSA9PiAoeyAuLi5lbnRyaWVzLCAuLi5zY2hlbWEuZW50cmllcyB9KSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICByZXN0LFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZVxuICApO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9vbWl0L29taXQudHNcbmZ1bmN0aW9uIG9taXQoc2NoZW1hLCBrZXlzLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gIGNvbnN0IFtyZXN0LCBtZXNzYWdlLCBwaXBlXSA9IHJlc3RBbmREZWZhdWx0QXJncyhhcmczLCBhcmc0LCBhcmc1KTtcbiAgcmV0dXJuIG9iamVjdChcbiAgICBPYmplY3QuZW50cmllcyhzY2hlbWEuZW50cmllcykucmVkdWNlKFxuICAgICAgKGVudHJpZXMsIFtrZXksIHNjaGVtYTJdKSA9PiBrZXlzLmluY2x1ZGVzKGtleSkgPyBlbnRyaWVzIDogeyAuLi5lbnRyaWVzLCBba2V5XTogc2NoZW1hMiB9LFxuICAgICAge31cbiAgICApLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlXG4gICk7XG59XG5cbi8vIHNyYy9tZXRob2RzL29taXQvb21pdEFzeW5jLnRzXG5mdW5jdGlvbiBvbWl0QXN5bmMoc2NoZW1hLCBrZXlzLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gIGNvbnN0IFtyZXN0LCBtZXNzYWdlLCBwaXBlXSA9IHJlc3RBbmREZWZhdWx0QXJncyhhcmczLCBhcmc0LCBhcmc1KTtcbiAgcmV0dXJuIG9iamVjdEFzeW5jKFxuICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5lbnRyaWVzKS5yZWR1Y2UoXG4gICAgICAoZW50cmllcywgW2tleSwgc2NoZW1hMl0pID0+IGtleXMuaW5jbHVkZXMoa2V5KSA/IGVudHJpZXMgOiB7IC4uLmVudHJpZXMsIFtrZXldOiBzY2hlbWEyIH0sXG4gICAgICB7fVxuICAgICksXG4gICAgcmVzdCxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGVcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvcGFyc2UvcGFyc2UudHNcbmZ1bmN0aW9uIHBhcnNlKHNjaGVtYSwgaW5wdXQsIGluZm8pIHtcbiAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlFcnJvcihyZXN1bHQuaXNzdWVzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0Lm91dHB1dDtcbn1cblxuLy8gc3JjL21ldGhvZHMvcGFyc2UvcGFyc2VBc3luYy50c1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VBc3luYyhzY2hlbWEsIGlucHV0LCBpbmZvKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNjaGVtYS5fcGFyc2UoaW5wdXQsIGluZm8pO1xuICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgIHRocm93IG5ldyBWYWxpRXJyb3IocmVzdWx0Lmlzc3Vlcyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5vdXRwdXQ7XG59XG5cbi8vIHNyYy9tZXRob2RzL3BhcnRpYWwvcGFydGlhbC50c1xuZnVuY3Rpb24gcGFydGlhbChzY2hlbWEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW3Jlc3QsIG1lc3NhZ2UsIHBpcGVdID0gcmVzdEFuZERlZmF1bHRBcmdzKGFyZzIsIGFyZzMsIGFyZzQpO1xuICByZXR1cm4gb2JqZWN0KFxuICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5lbnRyaWVzKS5yZWR1Y2UoXG4gICAgICAoZW50cmllcywgW2tleSwgc2NoZW1hMl0pID0+ICh7XG4gICAgICAgIC4uLmVudHJpZXMsXG4gICAgICAgIFtrZXldOiBvcHRpb25hbChzY2hlbWEyKVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICksXG4gICAgcmVzdCxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGVcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvcGFydGlhbC9wYXJ0aWFsQXN5bmMudHNcbmZ1bmN0aW9uIHBhcnRpYWxBc3luYyhzY2hlbWEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW3Jlc3QsIG1lc3NhZ2UsIHBpcGVdID0gcmVzdEFuZERlZmF1bHRBcmdzKGFyZzIsIGFyZzMsIGFyZzQpO1xuICByZXR1cm4gb2JqZWN0QXN5bmMoXG4gICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hLmVudHJpZXMpLnJlZHVjZShcbiAgICAgIChlbnRyaWVzLCBba2V5LCBzY2hlbWEyXSkgPT4gKHtcbiAgICAgICAgLi4uZW50cmllcyxcbiAgICAgICAgW2tleV06IG9wdGlvbmFsQXN5bmMoc2NoZW1hMilcbiAgICAgIH0pLFxuICAgICAge31cbiAgICApLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlXG4gICk7XG59XG5cbi8vIHNyYy9tZXRob2RzL3Bhc3N0aHJvdWdoL3Bhc3N0aHJvdWdoLnRzXG5mdW5jdGlvbiBwYXNzdGhyb3VnaChzY2hlbWEpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zY2hlbWEsXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZWQpIHtcbiAgICAgICAgcmVzdWx0Lm91dHB1dCA9IHsgLi4uaW5wdXQsIC4uLnJlc3VsdC5vdXRwdXQgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9wYXNzdGhyb3VnaC9wYXNzdGhyb3VnaEFzeW5jLnRzXG5mdW5jdGlvbiBwYXNzdGhyb3VnaEFzeW5jKHNjaGVtYSkge1xuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNjaGVtYS5fcGFyc2UoaW5wdXQsIGluZm8pO1xuICAgICAgaWYgKHJlc3VsdC50eXBlZCkge1xuICAgICAgICByZXN1bHQub3V0cHV0ID0geyAuLi5pbnB1dCwgLi4ucmVzdWx0Lm91dHB1dCB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3BpY2svcGljay50c1xuZnVuY3Rpb24gcGljayhzY2hlbWEsIGtleXMsIGFyZzMsIGFyZzQsIGFyZzUpIHtcbiAgY29uc3QgW3Jlc3QsIG1lc3NhZ2UsIHBpcGVdID0gcmVzdEFuZERlZmF1bHRBcmdzKGFyZzMsIGFyZzQsIGFyZzUpO1xuICByZXR1cm4gb2JqZWN0KFxuICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5lbnRyaWVzKS5yZWR1Y2UoXG4gICAgICAoZW50cmllcywgW2tleSwgc2NoZW1hMl0pID0+IGtleXMuaW5jbHVkZXMoa2V5KSA/IHsgLi4uZW50cmllcywgW2tleV06IHNjaGVtYTIgfSA6IGVudHJpZXMsXG4gICAgICB7fVxuICAgICksXG4gICAgcmVzdCxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGVcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvcGljay9waWNrQXN5bmMudHNcbmZ1bmN0aW9uIHBpY2tBc3luYyhzY2hlbWEsIGtleXMsIGFyZzMsIGFyZzQsIGFyZzUpIHtcbiAgY29uc3QgW3Jlc3QsIG1lc3NhZ2UsIHBpcGVdID0gcmVzdEFuZERlZmF1bHRBcmdzKGFyZzMsIGFyZzQsIGFyZzUpO1xuICByZXR1cm4gb2JqZWN0QXN5bmMoXG4gICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hLmVudHJpZXMpLnJlZHVjZShcbiAgICAgIChlbnRyaWVzLCBba2V5LCBzY2hlbWEyXSkgPT4ga2V5cy5pbmNsdWRlcyhrZXkpID8geyAuLi5lbnRyaWVzLCBba2V5XTogc2NoZW1hMiB9IDogZW50cmllcyxcbiAgICAgIHt9XG4gICAgKSxcbiAgICByZXN0LFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZVxuICApO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9yZXF1aXJlZC9yZXF1aXJlZC50c1xuZnVuY3Rpb24gcmVxdWlyZWQoc2NoZW1hLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFtyZXN0LCBtZXNzYWdlLCBwaXBlXSA9IHJlc3RBbmREZWZhdWx0QXJncyhhcmcyLCBhcmczLCBhcmc0KTtcbiAgcmV0dXJuIG9iamVjdChcbiAgICBPYmplY3QuZW50cmllcyhzY2hlbWEuZW50cmllcykucmVkdWNlKFxuICAgICAgKGVudHJpZXMsIFtrZXksIHNjaGVtYTJdKSA9PiAoe1xuICAgICAgICAuLi5lbnRyaWVzLFxuICAgICAgICBba2V5XTogbm9uT3B0aW9uYWwoc2NoZW1hMilcbiAgICAgIH0pLFxuICAgICAge31cbiAgICApLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlXG4gICk7XG59XG5cbi8vIHNyYy9tZXRob2RzL3JlcXVpcmVkL3JlcXVpcmVkQXN5bmMudHNcbmZ1bmN0aW9uIHJlcXVpcmVkQXN5bmMoc2NoZW1hLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFtyZXN0LCBtZXNzYWdlLCBwaXBlXSA9IHJlc3RBbmREZWZhdWx0QXJncyhhcmcyLCBhcmczLCBhcmc0KTtcbiAgcmV0dXJuIG9iamVjdEFzeW5jKFxuICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5lbnRyaWVzKS5yZWR1Y2UoXG4gICAgICAoZW50cmllcywgW2tleSwgc2NoZW1hMl0pID0+ICh7XG4gICAgICAgIC4uLmVudHJpZXMsXG4gICAgICAgIFtrZXldOiBub25PcHRpb25hbEFzeW5jKHNjaGVtYTIpXG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICByZXN0LFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZVxuICApO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9zYWZlUGFyc2Uvc2FmZVBhcnNlLnRzXG5mdW5jdGlvbiBzYWZlUGFyc2Uoc2NoZW1hLCBpbnB1dCwgaW5mbykge1xuICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlZDogcmVzdWx0LnR5cGVkLFxuICAgIHN1Y2Nlc3M6ICFyZXN1bHQuaXNzdWVzLFxuICAgIGRhdGE6IHJlc3VsdC5vdXRwdXQsXG4gICAgb3V0cHV0OiByZXN1bHQub3V0cHV0LFxuICAgIGVycm9yOiByZXN1bHQuaXNzdWVzICYmIG5ldyBWYWxpRXJyb3IocmVzdWx0Lmlzc3VlcyksXG4gICAgaXNzdWVzOiByZXN1bHQuaXNzdWVzXG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3NhZmVQYXJzZS9zYWZlUGFyc2VBc3luYy50c1xuYXN5bmMgZnVuY3Rpb24gc2FmZVBhcnNlQXN5bmMoc2NoZW1hLCBpbnB1dCwgaW5mbykge1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCBzY2hlbWEuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlZDogcmVzdWx0LnR5cGVkLFxuICAgIHN1Y2Nlc3M6ICFyZXN1bHQuaXNzdWVzLFxuICAgIGRhdGE6IHJlc3VsdC5vdXRwdXQsXG4gICAgb3V0cHV0OiByZXN1bHQub3V0cHV0LFxuICAgIGVycm9yOiByZXN1bHQuaXNzdWVzICYmIG5ldyBWYWxpRXJyb3IocmVzdWx0Lmlzc3VlcyksXG4gICAgaXNzdWVzOiByZXN1bHQuaXNzdWVzXG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3N0cmljdC9zdHJpY3QudHNcbmZ1bmN0aW9uIHN0cmljdChzY2hlbWEsIG1lc3NhZ2UgPSBcIkludmFsaWQga2V5c1wiKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgICByZXR1cm4gIXJlc3VsdC5pc3N1ZXMgJiYgT2JqZWN0LmtleXMoaW5wdXQpLnNvbWUoKGtleSkgPT4gIShrZXkgaW4gc2NoZW1hLmVudHJpZXMpKSA/IHNjaGVtYUlzc3VlKGluZm8sIFwib2JqZWN0XCIsIFwic3RyaWN0XCIsIG1lc3NhZ2UsIGlucHV0KSA6IHJlc3VsdDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3N0cmljdC9zdHJpY3RBc3luYy50c1xuZnVuY3Rpb24gc3RyaWN0QXN5bmMoc2NoZW1hLCBtZXNzYWdlID0gXCJJbnZhbGlkIGtleXNcIikge1xuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2NoZW1hLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgICByZXR1cm4gIXJlc3VsdC5pc3N1ZXMgJiYgT2JqZWN0LmtleXMoaW5wdXQpLnNvbWUoKGtleSkgPT4gIShrZXkgaW4gc2NoZW1hLmVudHJpZXMpKSA/IHNjaGVtYUlzc3VlKGluZm8sIFwib2JqZWN0XCIsIFwic3RyaWN0XCIsIG1lc3NhZ2UsIGlucHV0KSA6IHJlc3VsdDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3N0cmlwL3N0cmlwLnRzXG5mdW5jdGlvbiBzdHJpcChzY2hlbWEpIHtcbiAgbGV0IGNhY2hlZEtleXM7XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgICBpZiAocmVzdWx0LnR5cGVkKSB7XG4gICAgICAgIGNhY2hlZEtleXMgPSBjYWNoZWRLZXlzIHx8IE9iamVjdC5rZXlzKHNjaGVtYS5lbnRyaWVzKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGNhY2hlZEtleXMpIHtcbiAgICAgICAgICBvdXRwdXRba2V5XSA9IHJlc3VsdC5vdXRwdXRba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQub3V0cHV0ID0gb3V0cHV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3N0cmlwL3N0cmlwQXN5bmMudHNcbmZ1bmN0aW9uIHN0cmlwQXN5bmMoc2NoZW1hKSB7XG4gIGxldCBjYWNoZWRLZXlzO1xuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGluZm8pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNjaGVtYS5fcGFyc2UoaW5wdXQsIGluZm8pO1xuICAgICAgaWYgKHJlc3VsdC50eXBlZCkge1xuICAgICAgICBjYWNoZWRLZXlzID0gY2FjaGVkS2V5cyB8fCBPYmplY3Qua2V5cyhzY2hlbWEuZW50cmllcyk7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBjYWNoZWRLZXlzKSB7XG4gICAgICAgICAgb3V0cHV0W2tleV0gPSByZXN1bHQub3V0cHV0W2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Lm91dHB1dCA9IG91dHB1dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy90cmFuc2Zvcm0vdHJhbnNmb3JtLnRzXG5mdW5jdGlvbiB0cmFuc2Zvcm0oc2NoZW1hLCBhY3Rpb24sIGFyZzEpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zY2hlbWEsXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3BhcnNlKGlucHV0LCBpbmZvKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZWQpIHtcbiAgICAgICAgcmVzdWx0Lm91dHB1dCA9IGFjdGlvbihyZXN1bHQub3V0cHV0LCB7IGlzc3VlczogcmVzdWx0Lmlzc3VlcyB9KTtcbiAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMgfHwgIWFyZzEpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHQocmVzdWx0Lm91dHB1dCwgYXJnMSwgaW5mbywgdHlwZW9mIHJlc3VsdC5vdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmcxLl9wYXJzZShyZXN1bHQub3V0cHV0LCBpbmZvKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy90cmFuc2Zvcm0vdHJhbnNmb3JtQXN5bmMudHNcbmZ1bmN0aW9uIHRyYW5zZm9ybUFzeW5jKHNjaGVtYSwgYWN0aW9uLCBhcmcxKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgaW5mbykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2NoZW1hLl9wYXJzZShpbnB1dCwgaW5mbyk7XG4gICAgICBpZiAocmVzdWx0LnR5cGVkKSB7XG4gICAgICAgIHJlc3VsdC5vdXRwdXQgPSBhd2FpdCBhY3Rpb24ocmVzdWx0Lm91dHB1dCwgeyBpc3N1ZXM6IHJlc3VsdC5pc3N1ZXMgfSk7XG4gICAgICAgIGlmIChyZXN1bHQuaXNzdWVzIHx8ICFhcmcxKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmMoXG4gICAgICAgICAgICByZXN1bHQub3V0cHV0LFxuICAgICAgICAgICAgYXJnMSxcbiAgICAgICAgICAgIGluZm8sXG4gICAgICAgICAgICB0eXBlb2YgcmVzdWx0Lm91dHB1dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZzEuX3BhcnNlKHJlc3VsdC5vdXRwdXQsIGluZm8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3Vud3JhcC91bndyYXAudHNcbmZ1bmN0aW9uIHVud3JhcChzY2hlbWEpIHtcbiAgcmV0dXJuIHNjaGVtYS53cmFwcGVkO1xufVxuXG4vLyBzcmMvbWV0aG9kcy93aXRoRGVmYXVsdC93aXRoRGVmYXVsdC50c1xuZnVuY3Rpb24gd2l0aERlZmF1bHQoc2NoZW1hLCB2YWx1ZTIpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zY2hlbWEsXG4gICAgX3BhcnNlKGlucHV0LCBpbmZvKSB7XG4gICAgICByZXR1cm4gc2NoZW1hLl9wYXJzZShcbiAgICAgICAgaW5wdXQgPT09IHZvaWQgMCA/IHR5cGVvZiB2YWx1ZTIgPT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlMigpIDogdmFsdWUyIDogaW5wdXQsXG4gICAgICAgIGluZm9cbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxudmFyIHVzZURlZmF1bHQgPSB3aXRoRGVmYXVsdDtcblxuLy8gc3JjL3JlZ2V4LnRzXG52YXIgQklDX1JFR0VYID0gL15bQS1aXXs2fSg/ITAwKVtBLVpcXGRdezJ9KD86W0EtWlxcZF17M30pPyQvdTtcbnZhciBDVUlEMl9SRUdFWCA9IC9eW2Etel1bXFxkYS16XSokL3U7XG52YXIgREVDSU1BTF9SRUdFWCA9IC9eXFxkKyQvdTtcbnZhciBFTUFJTF9SRUdFWCA9IC9eW1xcdystXSsoPzpcXC5bXFx3Ky1dKykqQFtcXGRhLXpdKyg/OlsuLV1bXFxkYS16XSspKlxcLlthLXpdezIsfSQvaXU7XG52YXIgRU1PSklfUkVHRVggPSAvXltcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfVxccHtFbW9qaV9Db21wb25lbnR9XSskL3U7XG52YXIgSEVYQURFQ0lNQUxfUkVHRVggPSAvXigwaHwweCk/W1xcZGEtZl0rJC9pdTtcbnZhciBIRVhfQ09MT1JfUkVHRVggPSAvXiMoW1xcZGEtZl17M318W1xcZGEtZl17NH18W1xcZGEtZl17Nn18W1xcZGEtZl17OH0pJC9pdTtcbnZhciBJTUVJX1JFR0VYID0gL15cXGR7Mn0oPzpbIC98LV0/XFxkezZ9KXsyfVsgL3wtXT9cXGQkL3U7XG52YXIgSVBWNF9SRUdFWCA9IChcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZG9zLWRldGVjdG9yL25vLXVuc2FmZS1yZWdleCAtLSBmYWxzZSBwb3NpdGl2ZVxuICAvXig/Oig/OlsxLTldfDFcXGR8MlswLTRdKT9cXGR8MjVbMC01XSkoPzpcXC4oPzooPzpbMS05XXwxXFxkfDJbMC00XSk/XFxkfDI1WzAtNV0pKXszfSQvdVxuKTtcbnZhciBJUFY2X1JFR0VYID0gL14oPzooPzpbXFxkYS1mXXsxLDR9Oil7N31bXFxkYS1mXXsxLDR9fCg/OltcXGRhLWZdezEsNH06KXsxLDd9OnwoPzpbXFxkYS1mXXsxLDR9Oil7MSw2fTpbXFxkYS1mXXsxLDR9fCg/OltcXGRhLWZdezEsNH06KXsxLDV9KD86OltcXGRhLWZdezEsNH0pezEsMn18KD86W1xcZGEtZl17MSw0fTopezEsNH0oPzo6W1xcZGEtZl17MSw0fSl7MSwzfXwoPzpbXFxkYS1mXXsxLDR9Oil7MSwzfSg/OjpbXFxkYS1mXXsxLDR9KXsxLDR9fCg/OltcXGRhLWZdezEsNH06KXsxLDJ9KD86OltcXGRhLWZdezEsNH0pezEsNX18W1xcZGEtZl17MSw0fTooPzo6W1xcZGEtZl17MSw0fSl7MSw2fXw6KD86KD86OltcXGRhLWZdezEsNH0pezEsN318Oil8ZmU4MDooPzo6W1xcZGEtZl17MCw0fSl7MCw0fSVbXFxkYS16XSt8OjooPzpmezR9KD86OjB7MSw0fSk/Oik/KD86KD86MjVbMC01XXwoPzoyWzAtNF18MT9cXGQpP1xcZClcXC4pezN9KD86MjVbMC01XXwoPzoyWzAtNF18MT9cXGQpP1xcZCl8KD86W1xcZGEtZl17MSw0fTopezEsNH06KD86KD86MjVbMC01XXwoPzoyWzAtNF18MT9cXGQpP1xcZClcXC4pezN9KD86MjVbMC01XXwoPzoyWzAtNF18MT9cXGQpP1xcZCkpJC9pdTtcbnZhciBJU09fREFURV9SRUdFWCA9IC9eXFxkezR9LSg/OjBbMS05XXwxWzAtMl0pLSg/OlsxMl1cXGR8MFsxLTldfDNbMDFdKSQvdTtcbnZhciBJU09fREFURV9USU1FX1JFR0VYID0gL15cXGR7NH0tKD86MFsxLTldfDFbMC0yXSktKD86WzEyXVxcZHwwWzEtOV18M1swMV0pVCg/OjBcXGR8MVxcZHwyWzAtM10pOlswLTVdXFxkJC91O1xudmFyIElTT19USU1FX1JFR0VYID0gL14oPzowXFxkfDFcXGR8MlswLTNdKTpbMC01XVxcZCQvdTtcbnZhciBJU09fVElNRV9TRUNPTkRfUkVHRVggPSAvXig/OjBcXGR8MVxcZHwyWzAtM10pKD86OlswLTVdXFxkKXsyfSQvdTtcbnZhciBJU09fVElNRVNUQU1QX1JFR0VYID0gL15cXGR7NH0tKD86MFsxLTldfDFbMC0yXSktKD86WzEyXVxcZHwwWzEtOV18M1swMV0pVCg/OjBcXGR8MVxcZHwyWzAtM10pKD86OlswLTVdXFxkKXsyfVxcLlxcZHszfVokL3U7XG52YXIgSVNPX1dFRUtfUkVHRVggPSAvXlxcZHs0fS1XKD86MFsxLTldfFsxLTRdXFxkfDVbMC0zXSkkL3U7XG52YXIgTUFDNDhfUkVHRVggPSAvXig/OltcXGRhLWZdezJ9Oil7NX1bXFxkYS1mXXsyfSR8Xig/OltcXGRhLWZdezJ9LSl7NX1bXFxkYS1mXXsyfSR8Xig/OltcXGRhLWZdezR9XFwuKXsyfVtcXGRhLWZdezR9JC9pdTtcbnZhciBNQUM2NF9SRUdFWCA9IC9eKD86W1xcZGEtZl17Mn06KXs3fVtcXGRhLWZdezJ9JHxeKD86W1xcZGEtZl17Mn0tKXs3fVtcXGRhLWZdezJ9JHxeKD86W1xcZGEtZl17NH1cXC4pezN9W1xcZGEtZl17NH0kfF4oPzpbXFxkYS1mXXs0fTopezN9W1xcZGEtZl17NH0kL2l1O1xudmFyIE9DVEFMX1JFR0VYID0gL14oMG8pP1swLTddKyQvaXU7XG52YXIgVUxJRF9SRUdFWCA9IC9eW1xcZGEtaGprbW5wLXR2LXpdezI2fSQvaXU7XG52YXIgVVVJRF9SRUdFWCA9IC9eW1xcZGEtZl17OH0oPzotW1xcZGEtZl17NH0pezN9LVtcXGRhLWZdezEyfSQvaXU7XG5cbi8vIHNyYy90cmFuc2Zvcm1hdGlvbnMvdG9DdXN0b20vdG9DdXN0b20udHNcbmZ1bmN0aW9uIHRvQ3VzdG9tKGFjdGlvbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidG9fY3VzdG9tXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChhY3Rpb24oaW5wdXQpKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1hdGlvbnMvdG9DdXN0b20vdG9DdXN0b21Bc3luYy50c1xuZnVuY3Rpb24gdG9DdXN0b21Bc3luYyhhY3Rpb24pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRvX2N1c3RvbVwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChhd2FpdCBhY3Rpb24oaW5wdXQpKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1hdGlvbnMvdG9Mb3dlckNhc2UvdG9Mb3dlckNhc2UudHNcbmZ1bmN0aW9uIHRvTG93ZXJDYXNlKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidG9fbG93ZXJfY2FzZVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQudG9Mb2NhbGVMb3dlckNhc2UoKSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtYXRpb25zL3RvTWF4VmFsdWUvdG9NYXhWYWx1ZS50c1xuZnVuY3Rpb24gdG9NYXhWYWx1ZShyZXF1aXJlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidG9fbWF4X3ZhbHVlXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCA+IHRoaXMucmVxdWlyZW1lbnQgPyB0aGlzLnJlcXVpcmVtZW50IDogaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWF0aW9ucy90b01pblZhbHVlL3RvTWluVmFsdWUudHNcbmZ1bmN0aW9uIHRvTWluVmFsdWUocmVxdWlyZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRvX21pbl92YWx1ZVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQgPCB0aGlzLnJlcXVpcmVtZW50ID8gdGhpcy5yZXF1aXJlbWVudCA6IGlucHV0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1hdGlvbnMvdG9UcmltbWVkL3RvVHJpbW1lZC50c1xuZnVuY3Rpb24gdG9UcmltbWVkKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidG9fdHJpbW1lZFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQudHJpbSgpKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1hdGlvbnMvdG9UcmltbWVkRW5kL3RvVHJpbW1lZEVuZC50c1xuZnVuY3Rpb24gdG9UcmltbWVkRW5kKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidG9fdHJpbW1lZF9lbmRcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0LnRyaW1FbmQoKSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtYXRpb25zL3RvVHJpbW1lZFN0YXJ0L3RvVHJpbW1lZFN0YXJ0LnRzXG5mdW5jdGlvbiB0b1RyaW1tZWRTdGFydCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRvX3RyaW1tZWRfc3RhcnRcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0LnRyaW1TdGFydCgpKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1hdGlvbnMvdG9VcHBlckNhc2UvdG9VcHBlckNhc2UudHNcbmZ1bmN0aW9uIHRvVXBwZXJDYXNlKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidG9fdXBwZXJfY2FzZVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQudG9VcHBlckNhc2UoKSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvYmljL2JpYy50c1xuZnVuY3Rpb24gYmljKG1lc3NhZ2UgPSBcIkludmFsaWQgQklDXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImJpY1wiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBCSUNfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gIXRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dC50b1VwcGVyQ2FzZSgpKSA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2J5dGVzL2J5dGVzLnRzXG5mdW5jdGlvbiBieXRlcyhyZXF1aXJlbWVudCwgbWVzc2FnZSA9IFwiSW52YWxpZCBieXRlIGxlbmd0aFwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJieXRlc1wiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShpbnB1dCkubGVuZ3RoICE9PSB0aGlzLnJlcXVpcmVtZW50ID8gYWN0aW9uSXNzdWUodGhpcy50eXBlLCB0aGlzLm1lc3NhZ2UsIGlucHV0LCB0aGlzLnJlcXVpcmVtZW50KSA6IGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvY3JlZGl0Q2FyZC9jcmVkaXRDYXJkLnRzXG52YXIgU0FOSVRJWkVfUkVHRVggPSAvWy0gXSsvZ3U7XG52YXIgUFJPVklERVJfUkVHRVhfTElTVCA9IFtcbiAgLy8gQW1lcmljYW4gRXhwcmVzc1xuICAvXjNbNDddXFxkezEzfSQvdSxcbiAgLy8gRGluZXJzIENsdWJcbiAgL14zKD86MFswLTVdfFs2OF1cXGQpXFxkezExfSQvdSxcbiAgLy8gRGlzY292ZXJcbiAgL142KD86MDExfDVcXGR7Mn0pXFxkezEyLDE1fSQvdSxcbiAgLy8gSkNCXG4gIC9eKD86MjEzMXwxODAwfDM1XFxkezN9KVxcZHsxMX0kL3UsXG4gIC8vIE1hc3RlcmNhcmRcbiAgL141WzEtNV1cXGR7Mn18KDIyMlxcZHwyMlszLTldXFxkfDJbMy02XVxcZHsyfXwyN1swMV1cXGR8MjcyMClcXGR7MTJ9JC91LFxuICAvLyBVbmlvblBheVxuICAvXig2WzI3XVxcZHsxNH18ODFcXGR7MTQsMTd9KSQvdSxcbiAgLy8gVmlzYVxuICAvXjRcXGR7MTJ9KD86XFxkezMsNn0pPyQvdVxuXTtcbmZ1bmN0aW9uIGNyZWRpdENhcmQobWVzc2FnZSA9IFwiSW52YWxpZCBjcmVkaXQgY2FyZFwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJjcmVkaXRfY2FyZFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiAoaW5wdXQpID0+IHtcbiAgICAgIGNvbnN0IHNhbml0aXplZCA9IGlucHV0LnJlcGxhY2UoU0FOSVRJWkVfUkVHRVgsIFwiXCIpO1xuICAgICAgcmV0dXJuIFBST1ZJREVSX1JFR0VYX0xJU1Quc29tZSgocmVnZXgyKSA9PiByZWdleDIudGVzdChzYW5pdGl6ZWQpKSAmJiBpc0x1aG5BbGdvKHNhbml0aXplZCk7XG4gICAgfSxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiAhdGhpcy5yZXF1aXJlbWVudChpbnB1dCkgPyBhY3Rpb25Jc3N1ZSh0aGlzLnR5cGUsIHRoaXMubWVzc2FnZSwgaW5wdXQsIHRoaXMucmVxdWlyZW1lbnQpIDogYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9jdWlkMi9jdWlkMi50c1xuZnVuY3Rpb24gY3VpZDIobWVzc2FnZSA9IFwiSW52YWxpZCBDdWlkMlwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJjdWlkMlwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBDVUlEMl9SRUdFWCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2N1c3RvbS9jdXN0b20udHNcbmZ1bmN0aW9uIGN1c3RvbShyZXF1aXJlbWVudCwgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJjdXN0b21cIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiAhdGhpcy5yZXF1aXJlbWVudChpbnB1dCkgPyBhY3Rpb25Jc3N1ZSh0aGlzLnR5cGUsIHRoaXMubWVzc2FnZSwgaW5wdXQsIHRoaXMucmVxdWlyZW1lbnQpIDogYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9jdXN0b20vY3VzdG9tQXN5bmMudHNcbmZ1bmN0aW9uIGN1c3RvbUFzeW5jKHJlcXVpcmVtZW50LCBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImN1c3RvbVwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gIWF3YWl0IHRoaXMucmVxdWlyZW1lbnQoaW5wdXQpID8gYWN0aW9uSXNzdWUodGhpcy50eXBlLCB0aGlzLm1lc3NhZ2UsIGlucHV0LCB0aGlzLnJlcXVpcmVtZW50KSA6IGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvZGVjaW1hbC9kZWNpbWFsLnRzXG5mdW5jdGlvbiBkZWNpbWFsKG1lc3NhZ2UgPSBcIkludmFsaWQgZGVjaW1hbFwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJkZWNpbWFsXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IERFQ0lNQUxfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gIXRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkgPyBhY3Rpb25Jc3N1ZSh0aGlzLnR5cGUsIHRoaXMubWVzc2FnZSwgaW5wdXQsIHRoaXMucmVxdWlyZW1lbnQpIDogYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9lbWFpbC9lbWFpbC50c1xuZnVuY3Rpb24gZW1haWwobWVzc2FnZSA9IFwiSW52YWxpZCBlbWFpbFwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJlbWFpbFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBFTUFJTF9SRUdFWCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2Vtb2ppL2Vtb2ppLnRzXG5mdW5jdGlvbiBlbW9qaShtZXNzYWdlID0gXCJJbnZhbGlkIGVtb2ppXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVtb2ppXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IEVNT0pJX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoaW5wdXQpID8gYWN0aW9uSXNzdWUodGhpcy50eXBlLCB0aGlzLm1lc3NhZ2UsIGlucHV0LCB0aGlzLnJlcXVpcmVtZW50KSA6IGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvZW5kc1dpdGgvZW5kc1dpdGgudHNcbmZ1bmN0aW9uIGVuZHNXaXRoKHJlcXVpcmVtZW50LCBtZXNzYWdlID0gXCJJbnZhbGlkIGVuZFwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJlbmRzX3dpdGhcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiAhaW5wdXQuZW5kc1dpdGgodGhpcy5yZXF1aXJlbWVudCkgPyBhY3Rpb25Jc3N1ZSh0aGlzLnR5cGUsIHRoaXMubWVzc2FnZSwgaW5wdXQsIHRoaXMucmVxdWlyZW1lbnQpIDogYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9lcXVhbC9lcXVhbC50c1xuZnVuY3Rpb24gZXF1YWwocmVxdWlyZW1lbnQsIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZXF1YWxcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dCAhPT0gdGhpcy5yZXF1aXJlbWVudCA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2V4Y2x1ZGVzL2V4Y2x1ZGVzLnRzXG5mdW5jdGlvbiBleGNsdWRlcyhyZXF1aXJlbWVudCwgbWVzc2FnZSA9IFwiSW52YWxpZCBjb250ZW50XCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImV4Y2x1ZGVzXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gaW5wdXQuaW5jbHVkZXModGhpcy5yZXF1aXJlbWVudCkgPyBhY3Rpb25Jc3N1ZSh0aGlzLnR5cGUsIHRoaXMubWVzc2FnZSwgaW5wdXQsIHRoaXMucmVxdWlyZW1lbnQpIDogYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9maW5pdGUvZmluaXRlLnRzXG5mdW5jdGlvbiBmaW5pdGUobWVzc2FnZSA9IFwiSW52YWxpZCBmaW5pdGUgbnVtYmVyXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImZpbml0ZVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBOdW1iZXIuaXNGaW5pdGUsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gIXRoaXMucmVxdWlyZW1lbnQoaW5wdXQpID8gYWN0aW9uSXNzdWUodGhpcy50eXBlLCB0aGlzLm1lc3NhZ2UsIGlucHV0LCB0aGlzLnJlcXVpcmVtZW50KSA6IGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvaGV4YWRlY2ltYWwvaGV4YWRlY2ltYWwudHNcbmZ1bmN0aW9uIGhleGFkZWNpbWFsKG1lc3NhZ2UgPSBcIkludmFsaWQgaGV4YWRlY2ltYWxcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaGV4YWRlY2ltYWxcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudDogSEVYQURFQ0lNQUxfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gIXRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkgPyBhY3Rpb25Jc3N1ZSh0aGlzLnR5cGUsIHRoaXMubWVzc2FnZSwgaW5wdXQsIHRoaXMucmVxdWlyZW1lbnQpIDogYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9oZXhDb2xvci9oZXhDb2xvci50c1xuZnVuY3Rpb24gaGV4Q29sb3IobWVzc2FnZSA9IFwiSW52YWxpZCBoZXggY29sb3JcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaGV4X2NvbG9yXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IEhFWF9DT0xPUl9SRUdFWCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2ltZWkvaW1laS50c1xuZnVuY3Rpb24gaW1laShtZXNzYWdlID0gXCJJbnZhbGlkIElNRUlcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaW1laVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBbSU1FSV9SRUdFWCwgaXNMdWhuQWxnb10sXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gIXRoaXMucmVxdWlyZW1lbnRbMF0udGVzdChpbnB1dCkgfHwgIXRoaXMucmVxdWlyZW1lbnRbMV0oaW5wdXQpID8gYWN0aW9uSXNzdWUodGhpcy50eXBlLCB0aGlzLm1lc3NhZ2UsIGlucHV0LCB0aGlzLnJlcXVpcmVtZW50KSA6IGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvaW5jbHVkZXMvaW5jbHVkZXMudHNcbmZ1bmN0aW9uIGluY2x1ZGVzKHJlcXVpcmVtZW50LCBtZXNzYWdlID0gXCJJbnZhbGlkIGNvbnRlbnRcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaW5jbHVkZXNcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiAhaW5wdXQuaW5jbHVkZXMocmVxdWlyZW1lbnQpID8gYWN0aW9uSXNzdWUodGhpcy50eXBlLCB0aGlzLm1lc3NhZ2UsIGlucHV0LCB0aGlzLnJlcXVpcmVtZW50KSA6IGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvaW50ZWdlci9pbnRlZ2VyLnRzXG5mdW5jdGlvbiBpbnRlZ2VyKG1lc3NhZ2UgPSBcIkludmFsaWQgaW50ZWdlclwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJpbnRlZ2VyXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IE51bWJlci5pc0ludGVnZXIsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gIXRoaXMucmVxdWlyZW1lbnQoaW5wdXQpID8gYWN0aW9uSXNzdWUodGhpcy50eXBlLCB0aGlzLm1lc3NhZ2UsIGlucHV0LCB0aGlzLnJlcXVpcmVtZW50KSA6IGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvaXAvaXAudHNcbmZ1bmN0aW9uIGlwKG1lc3NhZ2UgPSBcIkludmFsaWQgSVBcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaXBcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudDogW0lQVjRfUkVHRVgsIElQVjZfUkVHRVhdLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuICF0aGlzLnJlcXVpcmVtZW50WzBdLnRlc3QoaW5wdXQpICYmICF0aGlzLnJlcXVpcmVtZW50WzFdLnRlc3QoaW5wdXQpID8gYWN0aW9uSXNzdWUodGhpcy50eXBlLCB0aGlzLm1lc3NhZ2UsIGlucHV0LCB0aGlzLnJlcXVpcmVtZW50KSA6IGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvaXB2NC9pcHY0LnRzXG5mdW5jdGlvbiBpcHY0KG1lc3NhZ2UgPSBcIkludmFsaWQgSVB2NFwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJpcHY0XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IElQVjRfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gIXRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkgPyBhY3Rpb25Jc3N1ZSh0aGlzLnR5cGUsIHRoaXMubWVzc2FnZSwgaW5wdXQsIHRoaXMucmVxdWlyZW1lbnQpIDogYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9pcHY2L2lwdjYudHNcbmZ1bmN0aW9uIGlwdjYobWVzc2FnZSA9IFwiSW52YWxpZCBJUHY2XCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImlwdjZcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudDogSVBWNl9SRUdFWCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2lzb0RhdGUvaXNvRGF0ZS50c1xuZnVuY3Rpb24gaXNvRGF0ZShtZXNzYWdlID0gXCJJbnZhbGlkIGRhdGVcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaXNvX2RhdGVcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudDogSVNPX0RBVEVfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gIXRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkgPyBhY3Rpb25Jc3N1ZSh0aGlzLnR5cGUsIHRoaXMubWVzc2FnZSwgaW5wdXQsIHRoaXMucmVxdWlyZW1lbnQpIDogYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9pc29EYXRlVGltZS9pc29EYXRlVGltZS50c1xuZnVuY3Rpb24gaXNvRGF0ZVRpbWUobWVzc2FnZSA9IFwiSW52YWxpZCBkYXRlLXRpbWVcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaXNvX2RhdGVfdGltZVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBJU09fREFURV9USU1FX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoaW5wdXQpID8gYWN0aW9uSXNzdWUodGhpcy50eXBlLCB0aGlzLm1lc3NhZ2UsIGlucHV0LCB0aGlzLnJlcXVpcmVtZW50KSA6IGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvaXNvVGltZS9pc29UaW1lLnRzXG5mdW5jdGlvbiBpc29UaW1lKG1lc3NhZ2UgPSBcIkludmFsaWQgdGltZVwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJpc29fdGltZVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBJU09fVElNRV9SRUdFWCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2lzb1RpbWVTZWNvbmQvaXNvVGltZVNlY29uZC50c1xuZnVuY3Rpb24gaXNvVGltZVNlY29uZChtZXNzYWdlID0gXCJJbnZhbGlkIHRpbWUgc2Vjb25kXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImlzb190aW1lX3NlY29uZFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBJU09fVElNRV9TRUNPTkRfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gIXRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkgPyBhY3Rpb25Jc3N1ZSh0aGlzLnR5cGUsIHRoaXMubWVzc2FnZSwgaW5wdXQsIHRoaXMucmVxdWlyZW1lbnQpIDogYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9pc29UaW1lc3RhbXAvaXNvVGltZXN0YW1wLnRzXG5mdW5jdGlvbiBpc29UaW1lc3RhbXAobWVzc2FnZSA9IFwiSW52YWxpZCB0aW1lc3RhbXBcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaXNvX3RpbWVzdGFtcFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBJU09fVElNRVNUQU1QX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoaW5wdXQpID8gYWN0aW9uSXNzdWUodGhpcy50eXBlLCB0aGlzLm1lc3NhZ2UsIGlucHV0LCB0aGlzLnJlcXVpcmVtZW50KSA6IGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvaXNvV2Vlay9pc29XZWVrLnRzXG5mdW5jdGlvbiBpc29XZWVrKG1lc3NhZ2UgPSBcIkludmFsaWQgd2Vla1wiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJpc29fd2Vla1wiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBJU09fV0VFS19SRUdFWCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2xlbmd0aC9sZW5ndGgudHNcbmZ1bmN0aW9uIGxlbmd0aChyZXF1aXJlbWVudCwgbWVzc2FnZSA9IFwiSW52YWxpZCBsZW5ndGhcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibGVuZ3RoXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gaW5wdXQubGVuZ3RoICE9PSB0aGlzLnJlcXVpcmVtZW50ID8gYWN0aW9uSXNzdWUodGhpcy50eXBlLCB0aGlzLm1lc3NhZ2UsIGlucHV0LCB0aGlzLnJlcXVpcmVtZW50KSA6IGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvbWFjL21hYy50c1xuZnVuY3Rpb24gbWFjKG1lc3NhZ2UgPSBcIkludmFsaWQgTUFDXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1hY1wiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBbTUFDNDhfUkVHRVgsIE1BQzY0X1JFR0VYXSxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiAhdGhpcy5yZXF1aXJlbWVudFswXS50ZXN0KGlucHV0KSAmJiAhdGhpcy5yZXF1aXJlbWVudFsxXS50ZXN0KGlucHV0KSA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL21hYzQ4L21hYzQ4LnRzXG5mdW5jdGlvbiBtYWM0OChtZXNzYWdlID0gXCJJbnZhbGlkIDQ4IGJpdCBNQUNcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibWFjNDhcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudDogTUFDNDhfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gIXRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkgPyBhY3Rpb25Jc3N1ZSh0aGlzLnR5cGUsIHRoaXMubWVzc2FnZSwgaW5wdXQsIHRoaXMucmVxdWlyZW1lbnQpIDogYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9tYWM2NC9tYWM2NC50c1xuZnVuY3Rpb24gbWFjNjQobWVzc2FnZSA9IFwiSW52YWxpZCA2NCBiaXQgTUFDXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1hYzY0XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IE1BQzY0X1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoaW5wdXQpID8gYWN0aW9uSXNzdWUodGhpcy50eXBlLCB0aGlzLm1lc3NhZ2UsIGlucHV0LCB0aGlzLnJlcXVpcmVtZW50KSA6IGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvbWF4Qnl0ZXMvbWF4Qnl0ZXMudHNcbmZ1bmN0aW9uIG1heEJ5dGVzKHJlcXVpcmVtZW50LCBtZXNzYWdlID0gXCJJbnZhbGlkIGJ5dGUgbGVuZ3RoXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1heF9ieXRlc1wiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShpbnB1dCkubGVuZ3RoID4gdGhpcy5yZXF1aXJlbWVudCA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL21heExlbmd0aC9tYXhMZW5ndGgudHNcbmZ1bmN0aW9uIG1heExlbmd0aChyZXF1aXJlbWVudCwgbWVzc2FnZSA9IFwiSW52YWxpZCBsZW5ndGhcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibWF4X2xlbmd0aFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuIGlucHV0Lmxlbmd0aCA+IHRoaXMucmVxdWlyZW1lbnQgPyBhY3Rpb25Jc3N1ZSh0aGlzLnR5cGUsIHRoaXMubWVzc2FnZSwgaW5wdXQsIHRoaXMucmVxdWlyZW1lbnQpIDogYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9tYXhTaXplL21heFNpemUudHNcbmZ1bmN0aW9uIG1heFNpemUocmVxdWlyZW1lbnQsIG1lc3NhZ2UgPSBcIkludmFsaWQgc2l6ZVwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJtYXhfc2l6ZVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuIGlucHV0LnNpemUgPiB0aGlzLnJlcXVpcmVtZW50ID8gYWN0aW9uSXNzdWUodGhpcy50eXBlLCB0aGlzLm1lc3NhZ2UsIGlucHV0LCB0aGlzLnJlcXVpcmVtZW50KSA6IGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvbWF4VmFsdWUvbWF4VmFsdWUudHNcbmZ1bmN0aW9uIG1heFZhbHVlKHJlcXVpcmVtZW50LCBtZXNzYWdlID0gXCJJbnZhbGlkIHZhbHVlXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1heF92YWx1ZVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuIGlucHV0ID4gdGhpcy5yZXF1aXJlbWVudCA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cbnZhciBtYXhSYW5nZSA9IG1heFZhbHVlO1xuXG4vLyBzcmMvdmFsaWRhdGlvbnMvbWluQnl0ZXMvbWluQnl0ZXMudHNcbmZ1bmN0aW9uIG1pbkJ5dGVzKHJlcXVpcmVtZW50LCBtZXNzYWdlID0gXCJJbnZhbGlkIGJ5dGUgbGVuZ3RoXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1pbl9ieXRlc1wiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShpbnB1dCkubGVuZ3RoIDwgdGhpcy5yZXF1aXJlbWVudCA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL21pbWVUeXBlL21pbWVUeXBlLnRzXG5mdW5jdGlvbiBtaW1lVHlwZShyZXF1aXJlbWVudCwgbWVzc2FnZSA9IFwiSW52YWxpZCBNSU1FIHR5cGVcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibWltZV90eXBlXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gIXRoaXMucmVxdWlyZW1lbnQuaW5jbHVkZXMoaW5wdXQudHlwZSkgPyBhY3Rpb25Jc3N1ZSh0aGlzLnR5cGUsIHRoaXMubWVzc2FnZSwgaW5wdXQsIHRoaXMucmVxdWlyZW1lbnQpIDogYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9taW5MZW5ndGgvbWluTGVuZ3RoLnRzXG5mdW5jdGlvbiBtaW5MZW5ndGgocmVxdWlyZW1lbnQsIG1lc3NhZ2UgPSBcIkludmFsaWQgbGVuZ3RoXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1pbl9sZW5ndGhcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dC5sZW5ndGggPCB0aGlzLnJlcXVpcmVtZW50ID8gYWN0aW9uSXNzdWUodGhpcy50eXBlLCB0aGlzLm1lc3NhZ2UsIGlucHV0LCB0aGlzLnJlcXVpcmVtZW50KSA6IGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvbWluU2l6ZS9taW5TaXplLnRzXG5mdW5jdGlvbiBtaW5TaXplKHJlcXVpcmVtZW50LCBtZXNzYWdlID0gXCJJbnZhbGlkIHNpemVcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibWluX3NpemVcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dC5zaXplIDwgdGhpcy5yZXF1aXJlbWVudCA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL21pblZhbHVlL21pblZhbHVlLnRzXG5mdW5jdGlvbiBtaW5WYWx1ZShyZXF1aXJlbWVudCwgbWVzc2FnZSA9IFwiSW52YWxpZCB2YWx1ZVwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJtaW5fdmFsdWVcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dCA8IHRoaXMucmVxdWlyZW1lbnQgPyBhY3Rpb25Jc3N1ZSh0aGlzLnR5cGUsIHRoaXMubWVzc2FnZSwgaW5wdXQsIHRoaXMucmVxdWlyZW1lbnQpIDogYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICB9XG4gIH07XG59XG52YXIgbWluUmFuZ2UgPSBtaW5WYWx1ZTtcblxuLy8gc3JjL3ZhbGlkYXRpb25zL211bHRpcGxlT2YvbXVsdGlwbGVPZi50c1xuZnVuY3Rpb24gbXVsdGlwbGVPZihyZXF1aXJlbWVudCwgbWVzc2FnZSA9IFwiSW52YWxpZCBtdWx0aXBsZVwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJtdWx0aXBsZV9vZlwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuIGlucHV0ICUgdGhpcy5yZXF1aXJlbWVudCAhPT0gMCA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL25vdEJ5dGVzL25vdEJ5dGVzLnRzXG5mdW5jdGlvbiBub3RCeXRlcyhyZXF1aXJlbWVudCwgbWVzc2FnZSA9IFwiSW52YWxpZCBieXRlIGxlbmd0aFwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJub3RfYnl0ZXNcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoaW5wdXQpLmxlbmd0aCA9PT0gdGhpcy5yZXF1aXJlbWVudCA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL25vdExlbmd0aC9ub3RMZW5ndGgudHNcbmZ1bmN0aW9uIG5vdExlbmd0aChyZXF1aXJlbWVudCwgbWVzc2FnZSA9IFwiSW52YWxpZCBsZW5ndGhcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibm90X2xlbmd0aFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuIGlucHV0Lmxlbmd0aCA9PT0gdGhpcy5yZXF1aXJlbWVudCA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL25vdFNpemUvbm90U2l6ZS50c1xuZnVuY3Rpb24gbm90U2l6ZShyZXF1aXJlbWVudCwgbWVzc2FnZSA9IFwiSW52YWxpZCBzaXplXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm5vdF9zaXplXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gaW5wdXQuc2l6ZSA9PT0gdGhpcy5yZXF1aXJlbWVudCA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL25vdFZhbHVlL25vdFZhbHVlLnRzXG5mdW5jdGlvbiBub3RWYWx1ZShyZXF1aXJlbWVudCwgbWVzc2FnZSA9IFwiSW52YWxpZCB2YWx1ZVwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJub3RfdmFsdWVcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dCA9PT0gdGhpcy5yZXF1aXJlbWVudCA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL29jdGFsL29jdGFsLnRzXG5mdW5jdGlvbiBvY3RhbChtZXNzYWdlID0gXCJJbnZhbGlkIG9jdGFsXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm9jdGFsXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IE9DVEFMX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoaW5wdXQpID8gYWN0aW9uSXNzdWUodGhpcy50eXBlLCB0aGlzLm1lc3NhZ2UsIGlucHV0LCB0aGlzLnJlcXVpcmVtZW50KSA6IGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvcmVnZXgvcmVnZXgudHNcbmZ1bmN0aW9uIHJlZ2V4KHJlcXVpcmVtZW50LCBtZXNzYWdlID0gXCJJbnZhbGlkIHJlZ2V4XCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInJlZ2V4XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gIXRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkgPyBhY3Rpb25Jc3N1ZSh0aGlzLnR5cGUsIHRoaXMubWVzc2FnZSwgaW5wdXQsIHRoaXMucmVxdWlyZW1lbnQpIDogYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9zYWZlSW50ZWdlci9zYWZlSW50ZWdlci50c1xuZnVuY3Rpb24gc2FmZUludGVnZXIobWVzc2FnZSA9IFwiSW52YWxpZCBzYWZlIGludGVnZXJcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic2FmZV9pbnRlZ2VyXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IE51bWJlci5pc1NhZmVJbnRlZ2VyLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuICF0aGlzLnJlcXVpcmVtZW50KGlucHV0KSA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL3NpemUvc2l6ZS50c1xuZnVuY3Rpb24gc2l6ZShyZXF1aXJlbWVudCwgbWVzc2FnZSA9IFwiSW52YWxpZCBzaXplXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInNpemVcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dC5zaXplICE9PSB0aGlzLnJlcXVpcmVtZW50ID8gYWN0aW9uSXNzdWUodGhpcy50eXBlLCB0aGlzLm1lc3NhZ2UsIGlucHV0LCB0aGlzLnJlcXVpcmVtZW50KSA6IGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvc3RhcnRzV2l0aC9zdGFydHNXaXRoLnRzXG5mdW5jdGlvbiBzdGFydHNXaXRoKHJlcXVpcmVtZW50LCBtZXNzYWdlID0gXCJJbnZhbGlkIHN0YXJ0XCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInN0YXJzX3dpdGhcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiAhaW5wdXQuc3RhcnRzV2l0aCh0aGlzLnJlcXVpcmVtZW50KSA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL3VsaWQvdWxpZC50c1xuZnVuY3Rpb24gdWxpZChtZXNzYWdlID0gXCJJbnZhbGlkIFVMSURcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidWxpZFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBVTElEX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoaW5wdXQpID8gYWN0aW9uSXNzdWUodGhpcy50eXBlLCB0aGlzLm1lc3NhZ2UsIGlucHV0LCB0aGlzLnJlcXVpcmVtZW50KSA6IGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvdXJsL3VybC50c1xuZnVuY3Rpb24gdXJsKG1lc3NhZ2UgPSBcIkludmFsaWQgVVJMXCIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInVybFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50KGlucHV0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgVVJMKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gIXRoaXMucmVxdWlyZW1lbnQoaW5wdXQpID8gYWN0aW9uSXNzdWUodGhpcy50eXBlLCB0aGlzLm1lc3NhZ2UsIGlucHV0LCB0aGlzLnJlcXVpcmVtZW50KSA6IGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvdXVpZC91dWlkLnRzXG5mdW5jdGlvbiB1dWlkKG1lc3NhZ2UgPSBcIkludmFsaWQgVVVJRFwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ1dWlkXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IFVVSURfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gIXRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkgPyBhY3Rpb25Jc3N1ZSh0aGlzLnR5cGUsIHRoaXMubWVzc2FnZSwgaW5wdXQsIHRoaXMucmVxdWlyZW1lbnQpIDogYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy92YWx1ZS92YWx1ZS50c1xuZnVuY3Rpb24gdmFsdWUocmVxdWlyZW1lbnQsIG1lc3NhZ2UgPSBcIkludmFsaWQgdmFsdWVcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidmFsdWVcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dCAhPT0gdGhpcy5yZXF1aXJlbWVudCA/IGFjdGlvbklzc3VlKHRoaXMudHlwZSwgdGhpcy5tZXNzYWdlLCBpbnB1dCwgdGhpcy5yZXF1aXJlbWVudCkgOiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cbmV4cG9ydCB7XG4gIEJJQ19SRUdFWCxcbiAgQnJhbmRTeW1ib2wsXG4gIENVSUQyX1JFR0VYLFxuICBERUNJTUFMX1JFR0VYLFxuICBFTUFJTF9SRUdFWCxcbiAgRU1PSklfUkVHRVgsXG4gIEhFWEFERUNJTUFMX1JFR0VYLFxuICBIRVhfQ09MT1JfUkVHRVgsXG4gIElNRUlfUkVHRVgsXG4gIElQVjRfUkVHRVgsXG4gIElQVjZfUkVHRVgsXG4gIElTT19EQVRFX1JFR0VYLFxuICBJU09fREFURV9USU1FX1JFR0VYLFxuICBJU09fVElNRVNUQU1QX1JFR0VYLFxuICBJU09fVElNRV9SRUdFWCxcbiAgSVNPX1RJTUVfU0VDT05EX1JFR0VYLFxuICBJU09fV0VFS19SRUdFWCxcbiAgTUFDNDhfUkVHRVgsXG4gIE1BQzY0X1JFR0VYLFxuICBPQ1RBTF9SRUdFWCxcbiAgVUxJRF9SRUdFWCxcbiAgVVVJRF9SRUdFWCxcbiAgVmFsaUVycm9yLFxuICBhY3Rpb25Jc3N1ZSxcbiAgYWN0aW9uT3V0cHV0LFxuICBhbnksXG4gIGFueUFzeW5jLFxuICBhcnJheSxcbiAgYXJyYXlBc3luYyxcbiAgYmljLFxuICBiaWdpbnQsXG4gIGJpZ2ludEFzeW5jLFxuICBibG9iLFxuICBibG9iQXN5bmMsXG4gIGJvb2xlYW4sXG4gIGJvb2xlYW5Bc3luYyxcbiAgYnJhbmQsXG4gIGJ5dGVzLFxuICBjb2VyY2UsXG4gIGNvZXJjZUFzeW5jLFxuICBjcmVkaXRDYXJkLFxuICBjdWlkMixcbiAgY3VzdG9tLFxuICBjdXN0b21Bc3luYyxcbiAgZGF0ZSxcbiAgZGF0ZUFzeW5jLFxuICBkZWNpbWFsLFxuICBkZWZhdWx0QXJncyxcbiAgZGlzY3JpbWluYXRlZFVuaW9uLFxuICBkaXNjcmltaW5hdGVkVW5pb25Bc3luYyxcbiAgZW1haWwsXG4gIGVtb2ppLFxuICBlbmRzV2l0aCxcbiAgZW51bUFzeW5jLFxuICBlbnVtVHlwZSxcbiAgZW51bVR5cGVBc3luYyxcbiAgZW51bV8sXG4gIGVxdWFsLFxuICBleGNsdWRlcyxcbiAgZmFsbGJhY2ssXG4gIGZhbGxiYWNrQXN5bmMsXG4gIGZpbml0ZSxcbiAgZmxhdHRlbixcbiAgZm9yd2FyZCxcbiAgZ2V0RGVmYXVsdCxcbiAgZ2V0RGVmYXVsdEFzeW5jLFxuICBnZXREZWZhdWx0cyxcbiAgZ2V0RGVmYXVsdHNBc3luYyxcbiAgZ2V0RmFsbGJhY2ssXG4gIGdldEZhbGxiYWNrQXN5bmMsXG4gIGdldEZhbGxiYWNrcyxcbiAgZ2V0RmFsbGJhY2tzQXN5bmMsXG4gIGhleENvbG9yLFxuICBoZXhhZGVjaW1hbCxcbiAgaW1laSxcbiAgaW5jbHVkZXMsXG4gIGluc3RhbmNlLFxuICBpbnN0YW5jZUFzeW5jLFxuICBpbnRlZ2VyLFxuICBpbnRlcnNlY3QsXG4gIGludGVyc2VjdGlvbixcbiAgaXAsXG4gIGlwdjQsXG4gIGlwdjYsXG4gIGlzLFxuICBpc0x1aG5BbGdvLFxuICBpc29EYXRlLFxuICBpc29EYXRlVGltZSxcbiAgaXNvVGltZSxcbiAgaXNvVGltZVNlY29uZCxcbiAgaXNvVGltZXN0YW1wLFxuICBpc29XZWVrLFxuICBrZXlvZixcbiAgbGVuZ3RoLFxuICBsaXRlcmFsLFxuICBsaXRlcmFsQXN5bmMsXG4gIG1hYyxcbiAgbWFjNDgsXG4gIG1hYzY0LFxuICBtYXAsXG4gIG1hcEFzeW5jLFxuICBtYXhCeXRlcyxcbiAgbWF4TGVuZ3RoLFxuICBtYXhSYW5nZSxcbiAgbWF4U2l6ZSxcbiAgbWF4VmFsdWUsXG4gIG1lcmdlLFxuICBtZXJnZUFzeW5jLFxuICBtaW1lVHlwZSxcbiAgbWluQnl0ZXMsXG4gIG1pbkxlbmd0aCxcbiAgbWluUmFuZ2UsXG4gIG1pblNpemUsXG4gIG1pblZhbHVlLFxuICBtdWx0aXBsZU9mLFxuICBuYW4sXG4gIG5hbkFzeW5jLFxuICBuYXRpdmVFbnVtLFxuICBuYXRpdmVFbnVtQXN5bmMsXG4gIG5ldmVyLFxuICBuZXZlckFzeW5jLFxuICBub25OdWxsYWJsZSxcbiAgbm9uTnVsbGFibGVBc3luYyxcbiAgbm9uTnVsbGlzaCxcbiAgbm9uTnVsbGlzaEFzeW5jLFxuICBub25PcHRpb25hbCxcbiAgbm9uT3B0aW9uYWxBc3luYyxcbiAgbm90Qnl0ZXMsXG4gIG5vdExlbmd0aCxcbiAgbm90U2l6ZSxcbiAgbm90VmFsdWUsXG4gIG51bGxBc3luYyxcbiAgbnVsbFR5cGUsXG4gIG51bGxUeXBlQXN5bmMsXG4gIG51bGxfLFxuICBudWxsYWJsZSxcbiAgbnVsbGFibGVBc3luYyxcbiAgbnVsbGlzaCxcbiAgbnVsbGlzaEFzeW5jLFxuICBudW1iZXIsXG4gIG51bWJlckFzeW5jLFxuICBvYmplY3QsXG4gIG9iamVjdEFzeW5jLFxuICBvY3RhbCxcbiAgb21pdCxcbiAgb21pdEFzeW5jLFxuICBvcHRpb25hbCxcbiAgb3B0aW9uYWxBc3luYyxcbiAgcGFyc2UsXG4gIHBhcnNlQXN5bmMsXG4gIHBhcnNlUmVzdWx0LFxuICBwYXJ0aWFsLFxuICBwYXJ0aWFsQXN5bmMsXG4gIHBhc3N0aHJvdWdoLFxuICBwYXNzdGhyb3VnaEFzeW5jLFxuICBwaWNrLFxuICBwaWNrQXN5bmMsXG4gIHBpY2tsaXN0LFxuICBwaWNrbGlzdEFzeW5jLFxuICBwaXBlUmVzdWx0LFxuICBwaXBlUmVzdWx0QXN5bmMsXG4gIHJlY29yZCxcbiAgcmVjb3JkQXN5bmMsXG4gIHJlY3Vyc2l2ZSxcbiAgcmVjdXJzaXZlQXN5bmMsXG4gIHJlZ2V4LFxuICByZXF1aXJlZCxcbiAgcmVxdWlyZWRBc3luYyxcbiAgcmVzdEFuZERlZmF1bHRBcmdzLFxuICBzYWZlSW50ZWdlcixcbiAgc2FmZVBhcnNlLFxuICBzYWZlUGFyc2VBc3luYyxcbiAgc2NoZW1hSXNzdWUsXG4gIHNldCxcbiAgc2V0QXN5bmMsXG4gIHNpemUsXG4gIHNwZWNpYWwsXG4gIHNwZWNpYWxBc3luYyxcbiAgc3RhcnRzV2l0aCxcbiAgc3RyaWN0LFxuICBzdHJpY3RBc3luYyxcbiAgc3RyaW5nLFxuICBzdHJpbmdBc3luYyxcbiAgc3RyaXAsXG4gIHN0cmlwQXN5bmMsXG4gIHN5bWJvbCxcbiAgc3ltYm9sQXN5bmMsXG4gIHRvQ3VzdG9tLFxuICB0b0N1c3RvbUFzeW5jLFxuICB0b0xvd2VyQ2FzZSxcbiAgdG9NYXhWYWx1ZSxcbiAgdG9NaW5WYWx1ZSxcbiAgdG9UcmltbWVkLFxuICB0b1RyaW1tZWRFbmQsXG4gIHRvVHJpbW1lZFN0YXJ0LFxuICB0b1VwcGVyQ2FzZSxcbiAgdHJhbnNmb3JtLFxuICB0cmFuc2Zvcm1Bc3luYyxcbiAgdHVwbGUsXG4gIHR1cGxlQXN5bmMsXG4gIHVsaWQsXG4gIHVuZGVmaW5lZEFzeW5jLFxuICB1bmRlZmluZWRUeXBlLFxuICB1bmRlZmluZWRUeXBlQXN5bmMsXG4gIHVuZGVmaW5lZF8sXG4gIHVuaW9uLFxuICB1bmlvbkFzeW5jLFxuICB1bmtub3duLFxuICB1bmtub3duQXN5bmMsXG4gIHVud3JhcCxcbiAgdXJsLFxuICB1c2VEZWZhdWx0LFxuICB1dWlkLFxuICB2YWx1ZSxcbiAgdmFyaWFudCxcbiAgdmFyaWFudEFzeW5jLFxuICB2b2lkQXN5bmMsXG4gIHZvaWRUeXBlLFxuICB2b2lkVHlwZUFzeW5jLFxuICB2b2lkXyxcbiAgd2l0aERlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/valibot/dist/index.js\n");

/***/ })

};
;